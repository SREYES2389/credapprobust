/**
 * @fileoverview
 * This Google Apps Script acts as the backend for the Verifiable Data Management web app.
 * It handles requests from the frontend (index.html) and performs CRUD operations
 * on a Google Sheet, which serves as the database.
 *
 * To use this script:
 * 1. Create a new Google Sheet.
 * 2. Go to Extensions > Apps Script in your Google Sheet.
 * 3. Replace any existing code in Code.gs with this script.
 * 4. Save the script.
 * 5. Reload the Google Sheet, and an "Admin" menu will appear.
 * 6. Click "Admin" > "Setup All Sheets" to initialize the database structure.
 * 7. Deploy the Apps Script as a web app.
 */

/**
 * Creates a custom menu in the spreadsheet UI to run setup functions.
 */
function onOpen() {
  SpreadsheetApp.getUi()
      .createMenu('Admin')
      .addItem('Setup All Sheets', 'setupSheets')
      .addItem('Add Mock Data', 'addMockData')
      .addToUi();
}

/**
 * Initializes all necessary sheets with their headers in the active spreadsheet.
 * This function is idempotent; it won't create sheets that already exist.
 */
function setupSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetsData = [
    { name: "Users", headers: ["ID", "Email", "First Name", "Last Name"] },
    { name: "Roles", headers: ["ID", "Name"] },
    { name: "ProviderTypes", headers: ["ID", "Name"] },
    { name: "FacilityLicenseTypes", headers: ["ID", "Name"] },
    { name: "Providers", headers: ["ID", "First Name", "Last Name", "NPI", "Next Credentialing Date", "Credentialing Status", "Deactivated"] },
    { name: "ProviderProfileImportSources", headers: ["Source", "Name", "Required Parameters (JSON)", "Has Pass-Through Fee", "Supports Re-import"] },
    { name: "FacilityProfileImports", headers: ["ID", "Facility ID", "Source", "Status", "Started", "Completed", "Failure Code", "Failure Reason", "Profile Data (JSON)"] },
    { name: "FacilityProfileImportSources", headers: ["Source", "Name", "Required Parameters (JSON)", "Has Pass-Through Fee", "Supports Re-import"] },
    { name: "LicenseTypes", headers: ["ID", "Taxonomy", "Name", "Aliases (JSON)", "Abbreviations (JSON)", "Sources (JSON)"] },
    { name: "Provider Aliases", headers: ["ID", "Provider ID", "First Name", "Last Name"] },
    { name: "Provider Addresses", headers: ["ID", "Provider ID", "Address Line 1", "Address Line 2", "City", "State", "Zip Code", "Type"] }, { name: "Provider Emails", headers: ["ID", "Provider ID", "Email", "Type"] },
    { name: "Notes", headers: ["ID", "Provider ID", "Facility ID", "Request ID", "Note", "Timestamp", "User Email", "Last Modified At", "Last Modified By"] },
    { name: "Facilities", headers: ["ID", "Name", "DBA", "Address Line 1", "Address Line 2", "City", "State", "Zip Code", "Phone Number", "Fax Number", "Group Tax ID", "Facility Tax ID", "Contact Name", "Contact Email", "Medicare Part A Number", "Medicare Part B Number", "Medicaid Number", "Deactivated"] },
    { name: "Facility Specialties", headers: ["ID", "Facility ID", "Taxonomy ID"] },
    { name: "Facility Taxonomies", headers: ["ID", "Code", "Name"] },
    { name: "Facility NPIs", headers: ["ID", "Facility ID", "NPI", "Is Active"] },
    { name: "Facility Licenses", headers: ["ID", "Facility ID", "License Type ID", "State", "License Number", "Is Primary", "Issue Date", "Expiration Date", "License Status"] },
    { name: "Provider Profile Imports", headers: ["ID", "Provider ID", "Source", "Status", "Started", "Completed", "Failure Code", "Failure Reason", "Profile Data (JSON)"] },
    { name: "Files", headers: ["ID", "Path", "Provider ID", "Facility ID", "Created At", "Created By User ID", "Created By User Email", "Size"] },
    { name: "Licenses", headers: ["ID", "Provider ID", "License Number", "First Name", "Last Name", "State", "Job Status", "Non Verified Issue Date", "Non Verified Expiration Date", "Non Verified Status", "Current Verification Status", "Current Verification ID", "Restriction Status", "Approved Status", "Is Primary", "Is Currently Practicing", "Prescriptive Authority", "Collaborating Provider ID", "License Type ID"] },
    { name: "License Verifications", headers: ["ID", "License ID", "Provider ID", "Original Status", "Status", "Trigger", "Started", "Processing Time", "Results (JSON)", "Additional Parameters (JSON)", "Verification Source (JSON)", "Failure Reason (JSON)", "Correct Result Index", "Export Path", "Monitoring Metadata (JSON)"] },
    { name: "License Source Status", headers: ["License Type ID", "State", "Issue", "Average Processing Time", "Average Failure Rate"] },
    { name: "Dataset Scans", headers: ["ID", "Type", "Provider ID", "Facility ID", "Status", "Started", "Completed", "Trigger", "Options (JSON)", "Failure Reason (JSON)", "Status Description (JSON)", "Parameters (JSON)", "Matches (JSON)", "Monitoring Metadata (JSON)", "Verified At", "Dataset Metadata (JSON)"] },
    { name: "Dataset Matches", headers: ["ID", "Dataset Timestamp", "Record Timestamp", "Data (JSON)", "Scan ID", "User Action Needed", "Is Ignored", "Match Score (JSON)", "User Action Resolution", "User Action Resolution Note", "Match Relevance", "Created Timestamp", "Obsolete Timestamp"] },
    { name: "Datasets Metadata", headers: ["Name", "Type", "Tags (JSON)", "Parameter Sets (JSON)", "Supported Entity Types (JSON)", "Status (JSON)", "Monitoring Intervals (JSON)", "Last Updated", "Schema (JSON)", "Properties (JSON)", "Capabilities (JSON)", "Maintenance Windows (JSON)", "Has Pass Through Fee"] },
    { name: "Groups", headers: ["ID", "Name", "NPI", "Tax ID", "Remit Address (JSON)"] },
    { name: "GroupProviders", headers: ["Group ID", "Provider ID"] },
    { name: "Payers", headers: ["ID", "Name"] },
    { name: "GroupPayers", headers: ["Group ID", "Payer ID"] },
    { name: "PayerPlans", headers: ["ID", "Payer ID", "Name", "State"] },
    { name: "ProviderEnrollments", headers: ["ID", "Group ID", "Payer Plan ID", "Provider ID", "Effective Date", "Enrollment Status", "Network Status", "Specialist Type", "Submission Date", "Closed Date", "External Provider Plan ID", "Comments"] },
    { name: "CredentialingRequests", headers: ["ID", "Provider ID", "Facility ID", "Type", "Priority", "Status", "Owner", "CreatedAt", "Current Event (JSON)"] },
    { name: "CredentialingRequestEvents", headers: ["ID", "Request ID", "Timestamp", "Status", "Note", "User", "Attachments (JSON)"] },
    { name: "Monitors", headers: ["ID", "Type", "Provider ID", "Dataset Type", "License ID", "Monitoring Interval", "Next Monitoring Date", "Last Monitoring Date", "Last Verification ID", "Options (JSON)"] },
    { name: "Alerts", headers: ["ID", "Provider ID", "Type", "Entity Type", "Entity ID", "Timestamp", "Dismissal Timestamp", "Dismissal Note", "Data (JSON)"] },
    { name: "Webhooks", headers: ["ID", "Type", "URL", "Secret", "Allow Insecure URL", "Include Sensitive Info"] },
    { name: "WebhookLogs", headers: ["ID", "Webhook ID", "Timestamp", "Status", "Payload (JSON)", "Response Status"] },
    { name: "AuditEvents", headers: ["ID", "Timestamp", "Type", "Message", "Correlation ID", "Context (JSON)"] },
    { name: "Reports", headers: ["ID", "Provider ID", "Facility ID", "Type", "Status", "StartedAt", "CompletedAt", "Path"] },
    { name: "NoteHistory", headers: ["History ID", "Note ID", "Old Note Text", "Timestamp", "User Email"] },
    { name: "Countries", headers: ["ID", "Name", "ISO Code", "CreatedAt"] },
    { name: "CredentialingChecklistItems", headers: ["ID", "Request ID", "Name", "Status", "Confirmed At", "Confirmed By", "Verified At", "Source", "References (JSON)"] },
    { name: "ProviderEducation", headers: ["ID", "Provider ID", "School Name", "Degree", "Graduate Type", "Start Date", "End Date"] },
    { name: "ProviderTraining", headers: ["ID", "Provider ID", "Institution Name", "Speciality", "Training Type", "Start Date", "End Date"] },
    { name: "ProviderWorkHistory", headers: ["ID", "Provider ID", "Name", "Job Title", "Start Date", "End Date", "Is Current Employer"] },
    { name: "ProviderBoardCertifications", headers: ["ID", "Provider ID", "Type", "Specialty", "Initial Certification Date", "Expiration Date"] },
    { name: "ProviderDeaRegistrations", headers: ["ID", "Provider ID", "Registration Number", "Last Updated At"] },
    { name: "ProviderProfileImportSources", headers: ["Source", "Name", "Required Parameters (JSON)", "Has Pass-Through Fee", "Supports Re-import"] },
    { name: "FacilityProfileImportSources", headers: ["Source", "Name", "Required Parameters (JSON)", "Has Pass-Through Fee", "Supports Re-import"] },
    { name: "FacilityAccreditations", headers: ["ID", "Facility ID", "Agency", "Program", "Decision", "Effective Date", "Expiration Date"] },
    { name: "FacilityCmsCertifications", headers: ["ID", "Facility ID", "Certification Number", "Certification Date"] }
  ];

  sheetsData.forEach(sheetData => {
    let sheet = ss.getSheetByName(sheetData.name);
    if (!sheet) {
      sheet = ss.insertSheet(sheetData.name);
      sheet.appendRow(sheetData.headers);
    }
  });
  SpreadsheetApp.getUi().alert('All sheets have been set up successfully.');
}

/**
 * Clears all data from all sheets (except headers) and populates them with mock data.
 */
function addMockData() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert('Confirm', 'This will delete all existing data and replace it with mock data. Are you sure you want to continue?', ui.ButtonSet.YES_NO);
  if (response !== ui.Button.YES) {
    return;
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const allSheets = ss.getSheets();
  
  // Clear all sheets first
  allSheets.forEach(sheet => {
    const lastRow = sheet.getLastRow();
    if (lastRow > 1) {
      sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn()).clearContent();
    }
  });

  // --- Generate Mock Data ---
  const userEmail = Session.getActiveUser().getEmail();
  const now = new Date();

  // Mock Users
  const usersSheet = getSheet("Users", ["ID", "Email", "First Name", "Last Name"]);
  const mockUsers = [
    [Utilities.getUuid(), userEmail, "Admin", "User"],
    [Utilities.getUuid(), "credentialer1@example.com", "Chris", "Credentialer"],
    [Utilities.getUuid(), "manager@example.com", "Mary", "Manager"]
  ];
  usersSheet.getRange(2, 1, mockUsers.length, mockUsers[0].length).setValues(mockUsers);

  // Mock Roles
    const rolesSheet = getSheet("Roles", ["ID", "Name"]);
    const mockRoles = [
      [Utilities.getUuid(), "Admin"],
      [Utilities.getUuid(), "Credentialer"],
      [Utilities.getUuid(), "Manager"],
      [Utilities.getUuid(), "Viewer"]
    ];
    rolesSheet.getRange(2, 1, mockRoles.length, mockRoles[0].length).setValues(mockRoles);

  // Mock Provider Types
  const providerTypesSheet = getSheet(PROVIDER_TYPES_SHEET_NAME, PROVIDER_TYPES_HEADERS);
  const mockProviderTypes = [
      [Utilities.getUuid(), "Physician"],
      [Utilities.getUuid(), "Nurse Practitioner"],
      [Utilities.getUuid(), "Physician Assistant"]
  ];
  providerTypesSheet.getRange(2, 1, mockProviderTypes.length, mockProviderTypes[0].length).setValues(mockProviderTypes);

  // Mock Facility License Types
  const facilityLicenseTypesSheet = getSheet(FACILITY_LICENSE_TYPES_SHEET_NAME, FACILITY_LICENSE_TYPES_HEADERS);
  const mockFacilityLicenseTypes = [
      [Utilities.getUuid(), "Hospital License"],
      [Utilities.getUuid(), "Ambulatory Surgical Center License"],
      [Utilities.getUuid(), "Clinical Laboratory License"]
  ];
  facilityLicenseTypesSheet.getRange(2, 1, mockFacilityLicenseTypes.length, mockFacilityLicenseTypes[0].length).setValues(mockFacilityLicenseTypes);
    
  // Mock Groups
  const groupsSheet = getSheet(GROUPS_SHEET_NAME, GROUPS_HEADERS);
  const mockGroups = [
    { id: Utilities.getUuid(), name: "General Medical Group", npi: "1234567890", taxId: "99-1234567" },
    { id: Utilities.getUuid(), name: "Specialty Surgical Center", npi: "0987654321", taxId: "99-7654321" },
    { id: Utilities.getUuid(), name: "Community Health Partners", npi: "1122334455", taxId: "99-1122334" }
  ];
  const groupRows = mockGroups.map(g => [g.id, g.name, g.npi, g.taxId, "{}"]);
  groupsSheet.getRange(2, 1, groupRows.length, groupRows[0].length).setValues(groupRows);

  // Mock Payers & Plans
  const payersSheet = getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS);
  const mockPayers = [
    { id: Utilities.getUuid(), name: "Aetna" },
    { id: Utilities.getUuid(), name: "Cigna" },
    { id: Utilities.getUuid(), name: "United Healthcare" }
  ];
  const payerRows = mockPayers.map(p => [p.id, p.name]);
  payersSheet.getRange(2, 1, payerRows.length, payerRows[0].length).setValues(payerRows);

  const plansSheet = getSheet(PAYER_PLANS_SHEET_NAME, PAYER_PLANS_HEADERS);
  const mockPlans = [
    { id: Utilities.getUuid(), payerId: mockPayers[0].id, name: "HMO Gold", state: "CA" },
    { id: Utilities.getUuid(), payerId: mockPayers[0].id, name: "PPO Silver", state: "CA" },
    { id: Utilities.getUuid(), payerId: mockPayers[1].id, name: "Open Access Plus", state: "NY" },
    { id: Utilities.getUuid(), payerId: mockPayers[2].id, name: "Choice Plus", state: "TX" }
  ];
  const planRows = mockPlans.map(p => [p.id, p.payerId, p.name, p.state]);
  plansSheet.getRange(2, 1, planRows.length, planRows[0].length).setValues(planRows);

  // Mock Providers
  const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
  const firstNames = ["John", "Jane", "Peter", "Mary", "David", "Susan", "Michael", "Linda", "James", "Patricia"];
  const lastNames = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez"];
  const statuses = ["Active", "Needs Review", "Data Collection", "Expired"];
  const mockProviders = [];
  for (let i = 0; i < 25; i++) {
    const nextCredDate = new Date(now.getTime() + (Math.random() * 365 - 90) * 24 * 60 * 60 * 1000);
    mockProviders.push({
      id: Utilities.getUuid(),
      firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
      lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
      npi: (1000000000 + Math.floor(Math.random() * 9000000000)).toString(),
      nextCredentialingDate: nextCredDate.toISOString().split('T')[0],
      credentialingStatus: statuses[i % statuses.length],
      deactivated: i % 10 === 0 // Deactivate some
    });
  }
  const providerRows = mockProviders.map(p => [p.id, p.firstName, p.lastName, p.npi, p.nextCredentialingDate, p.credentialingStatus, p.deactivated]);
  providersSheet.getRange(2, 1, providerRows.length, providerRows[0].length).setValues(providerRows);

  // Mock Facilities
  const facilitiesSheet = getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS);
  const mockFacilities = [
    { id: Utilities.getUuid(), name: "Downtown General Hospital", city: "Metropolis", state: "NY", deactivated: false },
    { id: Utilities.getUuid(), name: "Uptown Surgical Center", city: "Metropolis", state: "NY", deactivated: false },
    { id: Utilities.getUuid(), name: "Westside Clinic", city: "Gotham", state: "NJ", deactivated: false },
    { id: Utilities.getUuid(), name: "Oceanview Medical", city: "Coast City", state: "CA", deactivated: true },
  ];
  const facilityRows = mockFacilities.map(f => [f.id, f.name, "", "123 Main St", "", f.city, f.state, "12345", "555-1234", "555-5678", f.id.substring(0,8), f.id.substring(9,17), "Admin", "admin@example.com", "medA-" + f.id.substring(0,4), "medB-" + f.id.substring(0,4), "mcaid-" + f.id.substring(0,4), f.deactivated]);
  facilitiesSheet.getRange(2, 1, facilityRows.length, facilityRows[0].length).setValues(facilityRows);
  // Mock Enrollments
  const enrollmentsSheet = getSheet(PROVIDER_ENROLLMENTS_SHEET_NAME, PROVIDER_ENROLLMENTS_HEADERS);
  const mockEnrollments = [];
  for (let i = 0; i < 15; i++) {
    const effectiveDate = new Date(now.getTime() - (Math.random() * 730) * 24 * 60 * 60 * 1000);
    mockEnrollments.push([
      Utilities.getUuid(),
      mockGroups[i % mockGroups.length].id,
      mockPlans[i % mockPlans.length].id,
      mockProviders[i].id,
      effectiveDate.toISOString().split('T')[0],
      "Enrolled", "Par", "Specialist", "", "", "", ""
    ]);
  }
 enrollmentsSheet.getRange(2, 1, mockEnrollments.length, mockEnrollments[0].length).setValues(mockEnrollments);

  // Mock Credentialing Requests
  const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
  const eventsSheet = getSheet(CREDENTIALING_REQUEST_EVENTS_SHEET_NAME, CREDENTIALING_REQUEST_EVENTS_HEADERS);
  const checklistSheet = getSheet(CREDENTIALING_CHECKLIST_ITEMS_SHEET_NAME, CREDENTIALING_CHECKLIST_ITEMS_HEADERS);
  const requestStatuses = ["RequestSubmitted", "RequestInProgress", "AdditionalInformationRequested", "Completed", "CompletedWithConcern"];
  const mockRequests = [];
  const mockEvents = [];
  const mockChecklistItems = [];
  const defaultChecklistItems = ["Primary License Verified", "DEA Verified", "Board Certification Verified", "Sanctions & Exclusions Scan Clear", "Work History Confirmed"];

  for (let i = 0; i < 10; i++) {
    const reqId = Utilities.getUuid();
    const reqStatus = requestStatuses[i % requestStatuses.length];
    const reqCreatedAt = new Date(now.getTime() - (Math.random() * 180) * 24 * 60 * 60 * 1000).toISOString();
    const initialEvent = { id: Utilities.getUuid(), requestId: reqId, timestamp: reqCreatedAt, status: "RequestSubmitted", note: "Initial request created.", user: userEmail, attachments: [] };
    
    mockRequests.push([
      reqId,
      mockProviders[i].id, // Link to a provider
      "", // No facility for this mock
      "Initial", "Medium", reqStatus, userEmail, reqCreatedAt, JSON.stringify(initialEvent)
    ]);

    mockEvents.push([initialEvent.id, initialEvent.requestId, initialEvent.timestamp, initialEvent.status, initialEvent.note, initialEvent.user, JSON.stringify(initialEvent.attachments)]);
    
    // Add a second event for some requests
    if (i % 2 === 0 && reqStatus !== "RequestSubmitted") {
       const secondEvent = { id: Utilities.getUuid(), requestId: reqId, timestamp: new Date().toISOString(), status: reqStatus, note: `Status updated to ${reqStatus}.`, user: userEmail, attachments: [] };
       mockEvents.push([secondEvent.id, secondEvent.requestId, secondEvent.timestamp, secondEvent.status, secondEvent.note, secondEvent.user, JSON.stringify(secondEvent.attachments)]);
    }

    defaultChecklistItems.forEach((itemName, j) => {
        let itemStatus = "Pending";
        if (reqStatus.startsWith("Completed") || j < 2) itemStatus = "Completed";
        if (reqStatus === "RequestInProgress" && j === 0) itemStatus = "Completed";
        mockChecklistItems.push([Utilities.getUuid(), reqId, itemName, itemStatus, itemStatus === "Completed" ? new Date().toISOString() : "", itemStatus === "Completed" ? userEmail : "", "", "", "{}"]);
    });
  }
  requestsSheet.getRange(2, 1, mockRequests.length, mockRequests[0].length).setValues(mockRequests);
  eventsSheet.getRange(2, 1, mockEvents.length, mockEvents[0].length).setValues(mockEvents);
  checklistSheet.getRange(2, 1, mockChecklistItems.length, mockChecklistItems[0].length).setValues(mockChecklistItems);

  // Mock Notes
  const notesSheet = getSheet(NOTES_SHEET_NAME, NOTES_HEADERS);
  const mockNotes = [
    [Utilities.getUuid(), mockProviders[0].id, "", "", "Called provider to confirm address.", new Date().toISOString(), userEmail, "", ""],
    [Utilities.getUuid(), mockProviders[1].id, "", "", "Provider sent updated insurance info.", new Date().toISOString(), userEmail, "", ""],
    [Utilities.getUuid(), "", mockFacilities[0].id, "", "Facility accreditation is up for renewal next month.", new Date().toISOString(), userEmail, "", ""],
    [Utilities.getUuid(), "", "", mockRequests[0][0], "Awaiting documents from provider.", new Date().toISOString(), userEmail, "", ""],
    [Utilities.getUuid(), mockProviders[2].id, "", "", "Follow up on license verification needed.", new Date().toISOString(), userEmail, "", ""]
  ];
  notesSheet.getRange(2, 1, mockNotes.length, mockNotes[0].length).setValues(mockNotes);

  // Mock Files
  const filesSheet = getSheet(FILES_SHEET_NAME, FILES_HEADERS);
  const mockFiles = [
    [Utilities.getUuid(), "https://example.com/file1.pdf", mockProviders[0].id, "", new Date().toISOString(), userEmail, userEmail, 123456],
    [Utilities.getUuid(), "https://example.com/file2.jpg", mockProviders[0].id, "", new Date().toISOString(), userEmail, userEmail, 789012],
    [Utilities.getUuid(), "https://example.com/file3.pdf", "", mockFacilities[0].id, new Date().toISOString(), userEmail, userEmail, 345678]
  ];
  filesSheet.getRange(2, 1, mockFiles.length, mockFiles[0].length).setValues(mockFiles);
  // Mock Reports
  const reportsSheet = getSheet(REPORTS_SHEET_NAME, REPORTS_HEADERS);
  const mockReports = [
    // ID, Provider ID, Facility ID, Type, Status, StartedAt, CompletedAt, Path
    [Utilities.getUuid(), "", "", "Roster", "Completed", new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000).toISOString(), new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000 + 120000).toISOString(), "https://example.com/reports/roster_20231026.csv"],
    [Utilities.getUuid(), "", "", "Enrollments", "Completed", new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000).toISOString(), new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000 + 180000).toISOString(), "https://example.com/reports/enrollments_20231023.csv"],
    [Utilities.getUuid(), "", "", "ExpirableCredentials", "Completed", new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString(), new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000 + 90000).toISOString(), "https://example.com/reports/expirables_20231021.pdf"],
    [Utilities.getUuid(), "", "", "SanctionsAndExclusions", "Failed", new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000).toISOString(), new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000 + 30000).toISOString(), ""],
    [Utilities.getUuid(), "", "", "Roster", "Working", new Date().toISOString(), "", ""]
  ];
  reportsSheet.getRange(2, 1, mockReports.length, mockReports[0].length).setValues(mockReports);

  // Mock Licenses
  const licensesSheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
  const mockLicenses = [
    [Utilities.getUuid(), mockProviders[0].id, "MD12345", mockProviders[0].firstName, mockProviders[0].lastName, "CA", "Idle", "2020-01-01", "2025-01-01", "Active", "Found", "", "None", "Yes", true, true, "", "", "lic-type-1"],
    [Utilities.getUuid(), mockProviders[1].id, "RN67890", mockProviders[1].firstName, mockProviders[1].lastName, "NY", "Idle", "2019-06-15", "2024-06-15", "Active", "Found", "", "None", "Yes", true, true, "", "", "lic-type-2"]
  ];
  licensesSheet.getRange(2, 1, mockLicenses.length, mockLicenses[0].length).setValues(mockLicenses);

  // Mock Education
  const educationSheet = getSheet(PROVIDER_EDUCATION_SHEET_NAME, PROVIDER_EDUCATION_HEADERS);
  const mockEducation = [
    [Utilities.getUuid(), mockProviders[0].id, "State University School of Medicine", "MD", "Professional", "2010-09-01", "2014-05-20"],
    [Utilities.getUuid(), mockProviders[1].id, "City College of Nursing", "BSN", "Undergraduate", "2013-09-01", "2017-05-20"]
  ];
  educationSheet.getRange(2, 1, mockEducation.length, mockEducation[0].length).setValues(mockEducation);

// Mock Provider Profile Import Sources
const providerImportSourcesSheet = getSheet(PROVIDER_PROFILE_IMPORT_SOURCES_SHEET_NAME, PROVIDER_PROFILE_IMPORT_SOURCES_HEADERS);
const mockProviderImportSources = [
  ["Npi", "NPI Registry", "[]", false, true],
  ["CaqhPo", "CAQH ProView", JSON.stringify(["CaqhId"]), true, true],
  ["AmericanMedicalAssociationPhysician", "AMA Physician Profile", "[]", false, false]
];
providerImportSourcesSheet.getRange(2, 1, mockProviderImportSources.length, mockProviderImportSources[0].length).setValues(mockProviderImportSources);

// Mock Facility Profile Import Sources
const facilityImportSourcesSheet = getSheet(FACILITY_PROFILE_IMPORT_SOURCES_SHEET_NAME, FACILITY_PROFILE_IMPORT_SOURCES_HEADERS);
const mockFacilityImportSources = [
  ["Npi", "NPI Registry (Facility)", "[]", false, true],
  ["Medicare", "Medicare Enrollment Data", "[]", false, false]
];
facilityImportSourcesSheet.getRange(2, 1, mockFacilityImportSources.length, mockFacilityImportSources[0].length).setValues(mockFacilityImportSources);

  // Invalidate all caches
  const cache = CacheService.getScriptCache();
  allSheets.forEach(sheet => {
    const cacheKey = `${ss.getId()}_${sheet.getName()}_rowIndex`;
    cache.remove(cacheKey);
  });

  ui.alert('Mock data has been added successfully.');
}

// --- Sheet Names and Headers ---
// Users
const USERS_SHEET_NAME = "Users";
const USERS_HEADERS = ["ID", "Email", "First Name", "Last Name"];
const ROLES_SHEET_NAME = "Roles";
const ROLES_HEADERS = ["ID", "Name"];
const PROVIDER_TYPES_SHEET_NAME = "ProviderTypes";
const PROVIDER_TYPES_HEADERS = ["ID", "Name"];
const FACILITY_LICENSE_TYPES_SHEET_NAME = "FacilityLicenseTypes";
const FACILITY_LICENSE_TYPES_HEADERS = ["ID", "Name"];
const LICENSE_TYPES_SHEET_NAME = "LicenseTypes";
const LICENSE_TYPES_HEADERS = ["ID", "Taxonomy", "Name", "Aliases (JSON)", "Abbreviations (JSON)", "Sources (JSON)"];
// Core
const PROVIDERS_SHEET_NAME = "Providers";
const PROVIDERS_HEADERS = ["ID", "First Name", "Last Name", "NPI", "Next Credentialing Date", "Credentialing Status", "Deactivated"];
const FACILITIES_SHEET_NAME = "Facilities";
const FACILITIES_HEADERS = ["ID", "Name", "DBA", "Address Line 1", "Address Line 2", "City", "State", "Zip Code", "Phone Number", "Fax Number", "Group Tax ID", "Facility Tax ID", "Contact Name", "Contact Email", "Medicare Part A Number", "Medicare Part B Number", "Medicaid Number", "Deactivated"];
const NOTES_SHEET_NAME = "Notes";
const NOTES_HEADERS = ["ID", "Provider ID", "Facility ID", "Request ID", "Note", "Timestamp", "User Email", "Last Modified At", "Last Modified By"];
const FILES_SHEET_NAME = "Files";
const FILES_HEADERS = ["ID", "Path", "Provider ID", "Facility ID", "Created At", "Created By User ID", "Created By User Email", "Size"];

// Provider Info
const ALIASES_SHEET_NAME = "Provider Aliases";
const ALIASES_HEADERS = ["ID", "Provider ID", "First Name", "Last Name"];
const ADDRESSES_SHEET_NAME = "Provider Addresses";
const ADDRESSES_HEADERS = ["ID", "Provider ID", "Address Line 1", "Address Line 2", "City", "State", "Zip Code", "Type"];
const EMAILS_SHEET_NAME = "Provider Emails";
const EMAILS_HEADERS = ["ID", "Provider ID", "Email", "Type"];

// Facility Info
const FACILITY_SPECIALTIES_SHEET_NAME = "Facility Specialties";
const FACILITY_SPECIALTIES_HEADERS = ["ID", "Facility ID", "Taxonomy ID"];
const FACILITY_TAXONOMIES_SHEET_NAME = "Facility Taxonomies";
const FACILITY_TAXONOMIES_HEADERS = ["ID", "Code", "Name"];
const FACILITY_NPIS_SHEET_NAME = "Facility NPIs";
const FACILITY_NPIS_HEADERS = ["ID", "Facility ID", "NPI", "Is Active"];
const FACILITY_LICENSES_SHEET_NAME = "Facility Licenses";
const FACILITY_LICENSES_HEADERS = ["ID", "Facility ID", "License Type ID", "State", "License Number", "Is Primary", "Issue Date", "Expiration Date", "License Status"];

// Provider Profile Imports
const PROVIDER_PROFILE_IMPORTS_SHEET_NAME = "Provider Profile Imports";
const PROVIDER_PROFILE_IMPORTS_HEADERS = ["ID", "Provider ID", "Source", "Status", "Started", "Completed", "Failure Code", "Failure Reason", "Profile Data (JSON)"];

// Licenses & Verifications
const LICENSES_SHEET_NAME = "Licenses";
const LICENSES_HEADERS = ["ID", "Provider ID", "License Number", "First Name", "Last Name", "State", "Job Status", "Non Verified Issue Date", "Non Verified Expiration Date", "Non Verified Status", "Current Verification Status", "Current Verification ID", "Restriction Status", "Approved Status", "Is Primary", "Is Currently Practicing", "Prescriptive Authority", "Collaborating Provider ID", "License Type ID"];
const LICENSE_VERIFICATIONS_SHEET_NAME = "License Verifications";
const LICENSE_VERIFICATIONS_HEADERS = ["ID", "License ID", "Provider ID", "Original Status", "Status", "Trigger", "Started", "Processing Time", "Results (JSON)", "Additional Parameters (JSON)", "Verification Source (JSON)", "Failure Reason (JSON)", "Correct Result Index", "Export Path", "Monitoring Metadata (JSON)"];
const LICENSE_SOURCE_STATUS_SHEET_NAME = "License Source Status";
const LICENSE_SOURCE_STATUS_HEADERS = ["License Type ID", "State", "Issue", "Average Processing Time", "Average Failure Rate"];
const LICENSE_TYPES_SHEET_NAME = "LicenseTypes";
const LICENSE_TYPES_HEADERS = ["ID", "Taxonomy", "Name", "Aliases (JSON)", "Abbreviations (JSON)", "Sources (JSON)"];

// Datasets
const DATASET_SCANS_SHEET_NAME = "Dataset Scans";
const DATASET_SCANS_HEADERS = ["ID", "Type", "Provider ID", "Facility ID", "Status", "Started", "Completed", "Trigger", "Options (JSON)", "Failure Reason (JSON)", "Status Description (JSON)", "Parameters (JSON)", "Matches (JSON)", "Monitoring Metadata (JSON)", "Verified At", "Dataset Metadata (JSON)"];
const DATASET_MATCHES_SHEET_NAME = "Dataset Matches";
const DATASET_MATCHES_HEADERS = ["ID", "Dataset Timestamp", "Record Timestamp", "Data (JSON)", "Scan ID", "User Action Needed", "Is Ignored", "Match Score (JSON)", "User Action Resolution", "User Action Resolution Note", "Match Relevance", "Created Timestamp", "Obsolete Timestamp"];
const DATASETS_METADATA_SHEET_NAME = "Datasets Metadata";
const DATASETS_METADATA_HEADERS = ["Name", "Type", "Tags (JSON)", "Parameter Sets (JSON)", "Supported Entity Types (JSON)", "Status (JSON)", "Monitoring Intervals (JSON)", "Last Updated", "Schema (JSON)", "Properties (JSON)", "Capabilities (JSON)", "Maintenance Windows (JSON)", "Has Pass Through Fee"];

// Groups, Payers, Enrollments
const GROUPS_SHEET_NAME = "Groups";
const GROUPS_HEADERS = ["ID", "Name", "NPI", "Tax ID", "Remit Address (JSON)"];
const GROUP_PROVIDERS_SHEET_NAME = "GroupProviders";
const GROUP_PROVIDERS_HEADERS = ["Group ID", "Provider ID"];
const PAYERS_SHEET_NAME = "Payers";
const PAYERS_HEADERS = ["ID", "Name"];
const GROUP_PAYERS_SHEET_NAME = "GroupPayers";
const GROUP_PAYERS_HEADERS = ["Group ID", "Payer ID"];
const PAYER_PLANS_SHEET_NAME = "PayerPlans";
const PAYER_PLANS_HEADERS = ["ID", "Payer ID", "Name", "State"];
const PROVIDER_ENROLLMENTS_SHEET_NAME = "ProviderEnrollments";
const PROVIDER_ENROLLMENTS_HEADERS = ["ID", "Group ID", "Payer Plan ID", "Provider ID", "Effective Date", "Enrollment Status", "Network Status", "Specialist Type", "Submission Date", "Closed Date", "External Provider Plan ID", "Comments"];

// Credentialing
const CREDENTIALING_REQUESTS_SHEET_NAME = "CredentialingRequests";
const CREDENTIALING_REQUESTS_HEADERS = ["ID", "Provider ID", "Facility ID", "Type", "Priority", "Status", "Owner", "CreatedAt", "Current Event (JSON)"];
const CREDENTIALING_REQUEST_EVENTS_SHEET_NAME = "CredentialingRequestEvents";
const CREDENTIALING_REQUEST_EVENTS_HEADERS = ["ID", "Request ID", "Timestamp", "Status", "Note", "User", "Attachments (JSON)"];
const CREDENTIALING_CHECKLIST_ITEMS_SHEET_NAME = "CredentialingChecklistItems";
const CREDENTIALING_CHECKLIST_ITEMS_HEADERS = ["ID", "Request ID", "Name", "Status", "Confirmed At", "Confirmed By", "Verified At", "Source", "References (JSON)"];

// Monitoring & Alerts
const MONITORS_SHEET_NAME = "Monitors";
const MONITORS_HEADERS = ["ID", "Type", "Provider ID", "Dataset Type", "License ID", "Monitoring Interval", "Next Monitoring Date", "Last Monitoring Date", "Last Verification ID", "Options (JSON)"];
const ALERTS_SHEET_NAME = "Alerts";
const ALERTS_HEADERS = ["ID", "Provider ID", "Type", "Entity Type", "Entity ID", "Timestamp", "Dismissal Timestamp", "Dismissal Note", "Data (JSON)"];

// System & Integrations
const WEBHOOKS_SHEET_NAME = "Webhooks";
const WEBHOOKS_HEADERS = ["ID", "Type", "URL", "Secret", "Allow Insecure URL", "Include Sensitive Info"];
const WEBHOOK_LOGS_SHEET_NAME = "WebhookLogs";
const WEBHOOK_LOGS_HEADERS = ["ID", "Webhook ID", "Timestamp", "Status", "Payload (JSON)", "Response Status"];
const AUDIT_EVENTS_SHEET_NAME = "AuditEvents";
const AUDIT_EVENTS_HEADERS = ["ID", "Timestamp", "Type", "Message", "Correlation ID", "Context (JSON)"]
const REPORTS_SHEET_NAME = "Reports";
const REPORTS_HEADERS = ["ID", "Provider ID", "Facility ID", "Type", "Status", "StartedAt", "CompletedAt", "Path"];

// Definitions Models
const COUNTRIES_SHEET_NAME = "Countries";
const COUNTRIES_HEADERS = ["ID", "Name", "ISO Code", "CreatedAt"];
const NOTE_HISTORY_SHEET_NAME = "NoteHistory";
const NOTE_HISTORY_HEADERS = ["History ID", "Note ID", "Old Note Text", "Timestamp", "User Email"];

// Detailed Provider Info
const PROVIDER_EDUCATION_SHEET_NAME = "ProviderEducation";
const PROVIDER_EDUCATION_HEADERS = ["ID", "Provider ID", "School Name", "Degree", "Graduate Type", "Start Date", "End Date"];
const PROVIDER_TRAINING_SHEET_NAME = "ProviderTraining";
const PROVIDER_TRAINING_HEADERS = ["ID", "Provider ID", "Institution Name", "Speciality", "Training Type", "Start Date", "End Date"];
const PROVIDER_WORK_HISTORY_SHEET_NAME = "ProviderWorkHistory";
const PROVIDER_WORK_HISTORY_HEADERS = ["ID", "Provider ID", "Name", "Job Title", "Start Date", "End Date", "Is Current Employer"];
const PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME = "ProviderBoardCertifications";
const PROVIDER_BOARD_CERTIFICATIONS_HEADERS = ["ID", "Provider ID", "Type", "Specialty", "Initial Certification Date", "Expiration Date"];
const PROVIDER_DEA_REGISTRATIONS_SHEET_NAME = "ProviderDeaRegistrations";
const PROVIDER_DEA_REGISTRATIONS_HEADERS = ["ID", "Provider ID", "Registration Number", "Last Updated At"];
const PROVIDER_CERTIFICATES_SHEET_NAME = "ProviderCertificates"; // New sheet for Certificates
const PROVIDER_CERTIFICATES_HEADERS = ["ID", "Provider ID", "Type", "Certificate Number", "First Name", "Last Name", "Issue Date", "Expiration Date", "Certifying Organization"];
const PROVIDER_CAQH_INFO_SHEET_NAME = "ProviderCaqhInfo"; // New sheet for CAQH Info
const PROVIDER_CAQH_INFO_HEADERS = ["ID", "Provider ID", "CAQH ID", "Last Updated At"]; // New sheet for Liability Insurance
const PROVIDER_LIABILITY_INSURANCE_SHEET_NAME = "ProviderLiabilityInsurance";
const PROVIDER_LIABILITY_INSURANCE_HEADERS = ["ID", "Provider ID", "Name", "Is Self Insured", "Original Effective Date", "Current Effective Date", "Current Expiration Date", "Coverage Type", "Is Unlimited Coverage", "Includes Tail Coverage", "Occurrence Coverage Amount", "Aggregate Coverage Amount", "Policy Number"];
const PROVIDER_PROFILE_IMPORT_SOURCES_SHEET_NAME = "ProviderProfileImportSources";
const PROVIDER_PROFILE_IMPORT_SOURCES_HEADERS = ["Source", "Name", "Required Parameters (JSON)", "Has Pass-Through Fee", "Supports Re-import"]; 



// Detailed Facility Info
const FACILITY_ACCREDITATIONS_SHEET_NAME = "FacilityAccreditations";
const FACILITY_ACCREDITATIONS_HEADERS = ["ID", "Facility ID", "Agency", "Program", "Decision", "Effective Date", "Expiration Date"];
const FACILITY_CMS_CERTIFICATIONS_SHEET_NAME = "FacilityCmsCertifications";
const FACILITY_CMS_CERTIFICATIONS_HEADERS = ["ID", "Facility ID", "Certification Number", "Certification Date"];
const FACILITY_DEAS_SHEET_NAME = "FacilityDeas"; // New sheet for Facility DEAs
const FACILITY_DEAS_HEADERS = ["ID", "Facility ID", "DEA Number", "Drug Schedules", "State", "Expiration Date", "Business Activity Code", "Payment Indicator", "Is Active"]; // New sheet for Facility Liability Insurance
const FACILITY_LIABILITY_INSURANCE_SHEET_NAME = "FacilityLiabilityInsurance";
const FACILITY_LIABILITY_INSURANCE_HEADERS = ["ID", "Facility ID", "Name", "Is Self Insured", "Original Effective Date", "Current Effective Date", "Current Expiration Date", "Coverage Type", "Is Unlimited Coverage", "Includes Tail Coverage", "Occurrence Coverage Amount", "Aggregate Coverage Amount", "Policy Number"];
const FACILITY_PROFILE_IMPORT_SOURCES_SHEET_NAME = "FacilityProfileImportSources";
const FACILITY_PROFILE_IMPORT_SOURCES_HEADERS = ["Source", "Name", "Required Parameters (JSON)", "Has Pass-Through Fee", "Supports Re-import"]; 
const FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME = "FacilityMedicareEnrollments"; // New sheet for Facility Medicare Enrollments
const FACILITY_MEDICARE_ENROLLMENTS_HEADERS = ["ID", "Facility ID", "Medicare Number", "Effective Date", "Termination Date", "Enrollment Status"];


// --- Core Functions ---

/**
 * Serves the HTML file for the web app.
 */
function doGet() {
  return HtmlService.createHtmlOutputFromFile('index')
    .setTitle('Verifiable Data Management')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

/**
 * Gets the active spreadsheet and the specified sheet.
 * Initializes headers and mock data if the sheet is new.
 */
function getSheet(sheetName, sheetHeaders) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) {
    throw new Error("No active spreadsheet found. Please run this script from a Google Sheet.");
  }
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    sheet.appendRow(sheetHeaders); // Corrected: use sheetHeaders here
    // Populate mock data for specific sheets if newly created
    if (sheetName === FACILITY_TAXONOMIES_SHEET_NAME) {
      populateMockFacilityTaxonomies(sheet);
    } else if (sheetName === LICENSE_SOURCE_STATUS_SHEET_NAME) {
      populateMockLicenseSourceStatus(sheet);
    } else if (sheetName === DATASETS_METADATA_SHEET_NAME) {
      populateMockDatasetsMetadata(sheet);
    } else if (sheetName === PAYERS_SHEET_NAME) {
      populateMockPayers(sheet);
    } else if (sheetName === COUNTRIES_SHEET_NAME) {
      populateMockCountries(sheet);
    } else if (sheetName === PROVIDER_TYPES_SHEET_NAME) {
      // Add mock data for new sheets if needed, though addMockData() already handles this.
      // This is a fallback for individual sheet creation.
    } else if (sheetName === FACILITY_LICENSE_TYPES_SHEET_NAME) {
      // Fallback mock data population
      populateMockCountries(sheet);
    }
  }
  return sheet;
}


// --- Mock Data Population Functions ---

function populateMockFacilityTaxonomies(sheet) {
  const mockTaxonomies = [
    ["tax-id-1", "207Q00000X", "Allopathic & Osteopathic Physicians"],
    ["tax-id-2", "225100000X", "Ambulatory Surgical Center"],
    ["tax-id-3", "282N00000X", "Hospital"],
    ["tax-id-4", "363A00000X", "Physician Assistant"]
  ];
  sheet.getRange(2, 1, mockTaxonomies.length, mockTaxonomies[0].length).setValues(mockTaxonomies);
}

function populateMockLicenseSourceStatus(sheet) {
  const mockStatus = [
    ["0059f76a-280a-377a-73e2-ddfe86f4113c", "MO", "", 1.5, 0.05],
    ["bfb028f0-52ca-47f4-8181-6b4c8262d29c", "CA", "", 2.1, 0.10],
    ["c7e1d8f2-9a3b-4c5d-8e6f-7a8b9c0d1e2f", "NY", "PossibleIssue", 3.0, 0.15]
  ];
  sheet.getRange(2, 1, mockStatus.length, mockStatus[0].length).setValues(mockStatus);
}

function populateMockDatasetsMetadata(sheet) {
  const now = new Date().toISOString();
  const mockDatasets = [
    ["SAM", "Sam", JSON.stringify(["Sanctions", "Exclusions"]), JSON.stringify([{ id: "sam-param-set", entityType: "Practitioner", supportedParameterTypes: ["Name", "Npi"], requiredParameterTypes: ["Name"] }]), JSON.stringify({ expectedProcessingTime: 120 }), JSON.stringify(["Daily", "Weekly"]), now, "{}", "{}", JSON.stringify({ SupportsContinuousMonitoring: true, SupportsOnDemandScanning: true }), "[]", false],
    ["OIG Exclusions", "OigExclusions", JSON.stringify(["Exclusions"]), JSON.stringify([{ id: "oig-param-set", entityType: "Practitioner", supportedParameterTypes: ["Name"], requiredParameterTypes: ["Name"] }]), JSON.stringify({ expectedProcessingTime: 60 }), JSON.stringify(["Monthly"]), now, "{}", "{}", JSON.stringify({ SupportsOnDemandScanning: true }), "[]", false],
    ["State Sanctions & Exclusions", "StateSanctionsAndExclusions", JSON.stringify(["Sanctions", "Exclusions", "State"]), JSON.stringify([{ id: "state-param-set", entityType: "Practitioner", supportedParameterTypes: ["Name", "State"], requiredParameterTypes: ["Name", "State"] }]), JSON.stringify({ expectedProcessingTime: 180 }), JSON.stringify(["Quarterly"]), now, "{}", "{}", JSON.stringify({ SupportsOnDemandScanning: true }), "[]", true]
  ];
  sheet.getRange(2, 1, mockDatasets.length, mockDatasets[0].length).setValues(mockDatasets);
}

function populateMockPayers(sheet) {
  const mockPayers = [
    [Utilities.getUuid(), "Aetna"],
    [Utilities.getUuid(), "Cigna"],
    [Utilities.getUuid(), "United Healthcare"]
  ];
  sheet.getRange(2, 1, mockPayers.length, mockPayers[0].length).setValues(mockPayers);
}

function populateMockCountries(sheet) {
  const now = new Date().toISOString();
  const mockCountries = [
    [Utilities.getUuid(), "United States", "US", now],
    [Utilities.getUuid(), "Canada", "CA", now],
    [Utilities.getUuid(), "Mexico", "MX", now]
  ];
  sheet.getRange(2, 1, mockCountries.length, mockCountries[0].length).setValues(mockCountries);
}


// --- Helper Functions ---

function sheetDataToObjects(values) {
  if (values.length <= 1) return [];
  const headers = values[0];
  const data = [];
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const obj = {};
    for (let j = 0; j < headers.length; j++) {
      const originalHeader = headers[j];
      const key = originalHeader.replace(/(?:^|\s)\S/g, a => a.toUpperCase()).replace(/\s/g, '').replace(/\(JSON\)/g, '');
      const finalKey = key.charAt(0).toLowerCase() + key.slice(1);
      let value = row[j];
      if (originalHeader.includes("Is") || originalHeader === "Deactivated" || originalHeader === "User Action Needed" || originalHeader === "Is Ignored" || originalHeader === "Has Pass Through Fee") {
        value = (value === true || String(value).toLowerCase() === "true");
      } else if (originalHeader.includes("(JSON)") && typeof value === 'string' && value) {
        try { value = JSON.parse(value); } catch (e) { console.error(`Failed to parse JSON in '${originalHeader}':`, value, e); value = {}; }
      }
      obj[finalKey] = value;
    }
    data.push(obj);
  }
  return data;
}

function getOrCreateRowIndex(sheet, idColumnIndex) {
  const cache = CacheService.getScriptCache();
  const cacheKey = `${sheet.getParent().getId()}_${sheet.getName()}_rowIndex`;
  const cachedIndex = cache.get(cacheKey);
  if (cachedIndex) return new Map(JSON.parse(cachedIndex));
  const data = sheet.getDataRange().getValues();
  const index = new Map();
  for (let i = 1; i < data.length; i++) {
    index.set(data[i][idColumnIndex], i + 1);
  }
  cache.put(cacheKey, JSON.stringify(Array.from(index.entries())), 3600);
  return index;
}

function patchDetailedInfo(sheetName, id, dataToUpdate) {
  try {
    const sheet = getSheet(sheetName, []); // Headers don't matter as much here, but we need the sheet object.
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const idColumnIndex = headers.indexOf("ID");
    if (idColumnIndex === -1) {
        throw new Error(`"ID" column not found in sheet: ${sheetName}`);
    }

    const rowIndexMap = getOrCreateRowIndex(sheet, idColumnIndex);
    const rowNum = rowIndexMap.get(id);

    if (!rowNum) {
      return { success: false, message: `Record with ID ${id} not found in ${sheetName}.` };
    }

    const dataRow = sheet.getRange(rowNum, 1, 1, headers.length);
    const values = dataRow.getValues()[0];

    let updated = false;
    const camelCaseHeaders = headers.map(header => {
        const key = header.replace(/(?:^|\s)\S/g, a => a.toUpperCase()).replace(/\s/g, '').replace(/\(JSON\)/g, '');
        return key.charAt(0).toLowerCase() + key.slice(1);
    });

    for (let i = 0; i < headers.length; i++) {
      const headerKey = camelCaseHeaders[i];
      if (dataToUpdate.hasOwnProperty(headerKey) && headerKey !== 'id') {
        let newValue = dataToUpdate[headerKey];
        if (headers[i].includes("(JSON)") && typeof newValue === 'object' && newValue !== null) {
          newValue = JSON.stringify(newValue);
        }
        if (values[i] !== newValue) {
          values[i] = newValue;
          updated = true;
        }
      }
    }

    if (updated) {
      dataRow.setValues([values]);
      invalidateRowIndexCache(sheet);
      return { success: true, message: `Record ${id} in ${sheetName} updated successfully.` };
    } else {
      return { success: true, message: "No changes detected to update." };
    }

  } catch (e) {
    return { success: false, message: `Failed to update record in ${sheetName}: ${e.message}` };
  }
}

function invalidateRowIndexCache(sheet) {
  const cache = CacheService.getScriptCache();
  const cacheKey = `${sheet.getParent().getId()}_${sheet.getName()}_rowIndex`;
  cache.remove(cacheKey);
}

function deleteDetailedProviderInfo(sheetName, headers, recordId) {
  try {
    const sheet = getSheet(sheetName, headers);
    const idColumnIndex = headers.indexOf("ID");
    if (idColumnIndex === -1) {
      throw new Error(`"ID" column not found in sheet: ${sheetName}`);
    }
    const rowIndexMap = getOrCreateRowIndex(sheet, idColumnIndex);
    const rowNum = rowIndexMap.get(recordId);
    if (rowNum) {
      sheet.deleteRow(rowNum);
      invalidateRowIndexCache(sheet);
      return { success: true, message: `Record with ID ${recordId} deleted successfully from ${sheetName}.` };
    } else {
      return { success: false, message: `Record with ID ${recordId} not found in ${sheetName}.` };
    }
  } catch (error) {
    return { success: false, message: `Failed to delete record from ${sheetName}: ${error.message}` };
  }
}

function deleteRowsByColumnValue(sheet, columnIndex, valueToDelete) {
  const data = sheet.getDataRange().getValues();
  let rowsDeleted = 0;
  for (let i = data.length - 1; i >= 1; i--) {
    if (data[i][columnIndex] === valueToDelete) {
      sheet.deleteRow(i + 1);
      rowsDeleted++;
    }
  }
  if (rowsDeleted > 0) invalidateRowIndexCache(sheet);
  return rowsDeleted;
}

function logAuditEvent(type, message, context = {}) {
  try {
    const sheet = getSheet(AUDIT_EVENTS_SHEET_NAME, AUDIT_EVENTS_HEADERS);
    const newId = Utilities.getUuid();
    sheet.appendRow([newId, new Date().toISOString(), type, message, context.correlationId || "", JSON.stringify(context)]);
  } catch (e) {
    console.error(`Failed to log audit event: ${e.message}`);
  }
}

/**
 * Gets or creates a dedicated folder in Google Drive for file uploads.
 * Caches the folder ID in PropertiesService for efficiency.
 */
function getUploadFolder() {
  const properties = PropertiesService.getScriptProperties();
  const folderId = properties.getProperty('uploadFolderId');
  
  if (folderId) {
    try {
      return DriveApp.getFolderById(folderId);
    } catch (e) {
      // Folder might have been deleted, fall through to create a new one
    }
  }

  const folderName = "WebAppUploads";
  const folders = DriveApp.getFoldersByName(folderName);
  
  const folder = folders.hasNext() ? folders.next() : DriveApp.createFolder(folderName);
  properties.setProperty('uploadFolderId', folder.getId());
  return folder;
}

/**
 * A generic function to create a sub-entity record.
 * @param {string} sheetName - The name of the sheet to add to.
 * @param {Array<string>} headers - The headers for the sheet.
 * @param {string} parentId - The ID of the parent entity (e.g., providerId).
 * @param {Array<any>} rowData - The array of data for the new row, excluding the new UUID.
 * @param {string} logMessage - A message for the audit log.
 * @returns {object} A success or error object.
 */
function createSubEntity(sheetName, headers, parentId, rowData, logMessage) {
  try {
    const sheet = getSheet(sheetName, headers);
    const newId = Utilities.getUuid();
    sheet.appendRow([newId, parentId, ...rowData]);
    invalidateRowIndexCache(sheet);
    logAuditEvent("Request", `${logMessage} created`, { parentId: parentId, newRecordId: newId });
    return { success: true, message: `${logMessage} created successfully.` };
  } catch (error) {
    logAuditEvent("Error", `Failed to create sub-entity in ${sheetName}: ${error.message}`);
    return { success: false, message: `Failed to create record: ${error.message}` };
  }
}

// --- Dashboard Functions ---

/**
 * Retrieves key metrics for the credentialing dashboard.
 * @returns {Object} An object containing dashboard metrics and task lists.
 */
function getDashboardMetrics() {
  try {
    // Metric 1: Providers Due for Re-credentialing
    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
    const ninetyDaysFromNow = new Date();
    ninetyDaysFromNow.setDate(ninetyDaysFromNow.getDate() + 90);

    const providersDue = allProviders.filter(p => {
      if (!p.nextCredentialingDate || p.deactivated) return false;
      const dueDate = new Date(p.nextCredentialingDate);
      return dueDate <= ninetyDaysFromNow;
    }).sort((a, b) => new Date(a.nextCredentialingDate) - new Date(b.nextCredentialingDate));

    const dueForRecredCount = providersDue.length;
    const top5ProvidersDue = providersDue.slice(0, 5);

    // Metric 2: Open Credentialing Requests
    const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const allRequests = sheetDataToObjects(requestsSheet.getDataRange().getValues());
    const openStatuses = ["RequestSubmitted", "RequestInProgress", "AdditionalInformationRequested", "AdditionalInformationSubmitted", "SecondAttemptMissingInfo", "ThirdAttemptMissingInfo"];
    const openRequests = allRequests.filter(r => openStatuses.includes(r.status));
    const openRequestsCount = openRequests.length;

    const requestsNeedingReview = allRequests
      .filter(r => r.status === "AdditionalInformationRequested" || r.status === "NeedsReview")
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
      .slice(0, 5);
      
// New: Recent Activity Log
    const auditSheet = getSheet(AUDIT_EVENTS_SHEET_NAME, AUDIT_EVENTS_HEADERS);
    const allAuditEvents = sheetDataToObjects(auditSheet.getDataRange().getValues());
    const recentActivity = allAuditEvents
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
      .slice(0, 10); // Get the last 10 events

    // Metric 3: Active Alerts
    const alertsSheet = getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS);
    const allAlerts = sheetDataToObjects(alertsSheet.getDataRange().getValues());
    const activeAlertsCount = allAlerts.filter(a => !a.dismissalTimestamp).length;

    // Metric 4: Unmonitored Licenses
    const licensesSheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    const allLicenses = sheetDataToObjects(licensesSheet.getDataRange().getValues());
    const monitorsSheet = getSheet(MONITORS_SHEET_NAME, MONITORS_HEADERS);
    const allMonitors = sheetDataToObjects(monitorsSheet.getDataRange().getValues());
    
    const monitoredLicenseIds = new Set(allMonitors.filter(m => m.type === 'License' && m.licenseId).map(m => m.licenseId));
    const unmonitoredLicensesCount = allLicenses.filter(l => !monitoredLicenseIds.has(l.id)).length;

    const dashboardData = {
      metrics: { dueForRecred: dueForRecredCount, openRequests: openRequestsCount, activeAlerts: activeAlertsCount, unmonitoredLicenses: unmonitoredLicensesCount },
      lists: {
        providersDue: top5ProvidersDue,
        requestsNeedingReview: requestsNeedingReview,
        recentActivity: recentActivity
      }
    };

    return { success: true, data: dashboardData };

  } catch (error) {
    logAuditEvent("Error", `Failed to get dashboard metrics: ${error.message}`);
    return { success: false, message: `Failed to get dashboard metrics: ${error.message}` };
  }
  }

/**
 * Lists event log entries with filtering, sorting, and pagination.
 * @param {object} options - An object with pagination, sorting, and filtering parameters.
 * @param {number} [options.page=1] - The page number to retrieve.
 * @param {number} [options.pageSize=25] - The number of records per page.
 * @param {string} [options.searchTerm=''] - A term to search for in message, correlation ID, or context.
 * @param {string} [options.typeFilter=''] - A specific event type to filter by (e.g., 'Error', 'Request').
 * @param {string} [options.sortBy='timestamp'] - The field to sort by.
 * @param {string} [options.sortOrder='desc'] - The sort order ('asc' or 'desc').
 * @returns {object} An object with the list of events and pagination info.
 */
function listEventLogEntries(options = {}) {
  try {
    const { page = 1, pageSize = 25, searchTerm = '', typeFilter = '', sortBy = 'timestamp', sortOrder = 'desc' } = options;
    
    const sheet = getSheet(AUDIT_EVENTS_SHEET_NAME, AUDIT_EVENTS_HEADERS);
    let allEvents = sheetDataToObjects(sheet.getDataRange().getValues());

    // Filtering
    if (typeFilter) {
      allEvents = allEvents.filter(event => event.type && event.type.toLowerCase() === typeFilter.toLowerCase());
    }

    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allEvents = allEvents.filter(event => {
        const messageMatch = event.message && event.message.toLowerCase().includes(lowercasedTerm);
        const correlationIdMatch = event.correlationId && event.correlationId.toLowerCase().includes(lowercasedTerm);
        // Search within the stringified context
        const contextString = typeof event.context === 'object' ? JSON.stringify(event.context).toLowerCase() : (event.context || '').toLowerCase();
        const contextMatch = contextString.includes(lowercasedTerm);
        
        return messageMatch || correlationIdMatch || contextMatch;
      });
    }

    // Sorting
    allEvents.sort((a, b) => {
      const valA = a[sortBy] || '';
      const valB = b[sortBy] || '';
      
      let comparison = 0;
      if (sortBy === 'timestamp') {
        comparison = new Date(valA) > new Date(valB) ? 1 : -1;
      } else {
        if (String(valA).toLowerCase() > String(valB).toLowerCase()) {
          comparison = 1;
        } else if (String(valA).toLowerCase() < String(valB).toLowerCase()) {
          comparison = -1;
        }
      }
      return sortOrder === 'desc' ? comparison * -1 : comparison;
    });

    const totalRecords = allEvents.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allEvents.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list event log entries: ${error.message}`);
    return { success: false, message: `Failed to list event log entries: ${error.message}` };
  }
}
function bulkUpdateProviderStatus(providerIds, newStatus) {
  if (!providerIds || providerIds.length === 0 || !newStatus) {
    return { success: false, message: "Provider IDs and a new status are required for bulk update." };
  }
  try {
    const sheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const idColIndex = headers.indexOf("ID");
    const statusColIndex = headers.indexOf("Credentialing Status");
    if (idColIndex === -1 || statusColIndex === -1) {
      throw new Error("Required columns (ID, Credentialing Status) not found in Providers sheet.");
    }

    const rowIndexMap = getOrCreateRowIndex(sheet, idColIndex);
    let updatedCount = 0;

    providerIds.forEach(id => {
      const rowNum = rowIndex.get(id);
      if (rowNum) {
        sheet.getRange(rowNum, statusColIndex + 1).setValue(newStatus);
        updatedCount++;
      }
    });

    if (updatedCount > 0) {
      logAuditEvent("Request", `Bulk updated status to '${newStatus}' for ${updatedCount} providers.`, { providerIds: providerIds, newStatus: newStatus });
      return { success: true, message: `Successfully updated status for ${updatedCount} providers.` };
    } else {
      return { success: false, message: "No matching providers found to update." };
    }
  } catch (e) {
    logAuditEvent("Error", `Bulk provider update failed: ${e.message}`);
    return { success: false, message: `Bulk update failed: ${e.message}` };
  }
}

// --- Provider Functions ---

function createProvider(providerData) {
  try {
    const sheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const newId = Utilities.getUuid();
    const rowData = [newId, providerData.firstName, providerData.lastName, providerData.npi || "", providerData.nextCredentialingDate || "", providerData.credentialingStatus, providerData.deactivated || false];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);
    logAuditEvent("Request", `Provider created: ${providerData.firstName} ${providerData.lastName}`, { providerId: newId });
    return { success: true, message: `Provider "${providerData.firstName} ${providerData.lastName}" added with ID: ${newId}` };
  } catch (error) {
    return { success: false, message: `Failed to add provider: ${error.message}` };
  }
}

function getProviders(options = {}) {
  try {
    const { page = 1, pageSize = 15, searchTerm = '', sortBy, sortOrder = 'asc' } = options;
    const sheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    let allProviders = sheetDataToObjects(sheet.getDataRange().getValues());

    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allProviders = allProviders.filter(p => {
        const fullName = `${p.firstName || ''} ${p.lastName || ''}`.toLowerCase();
        return (p.id && p.id.toLowerCase().includes(lowercasedTerm)) ||
               fullName.includes(lowercasedTerm) ||
               (p.npi && p.npi.toString().includes(lowercasedTerm));
      });
    }

    if (sortBy) {
      allProviders.sort((a, b) => {
        const valA = a[sortBy] || '';
        const valB = b[sortBy] || '';
        let comparison = 0;
        if (valA > valB) {
          comparison = 1;
        } else if (valA < valB) {
          comparison = -1;
        }
        return sortOrder === 'desc' ? comparison * -1 : comparison;
      });
    }

    const totalRecords = allProviders.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allProviders.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    return { success: false, message: `Failed to retrieve providers: ${error.message}` };
  }
}

function updateProvider(providerData) {
  // This function now uses the generic patchDetailedInfo helper.
  // The specific logic for updating a provider row is now centralized.
  const result = patchDetailedInfo(PROVIDERS_SHEET_NAME, providerData.id, providerData);
  if (result.success) {
    logAuditEvent("Request", `Provider updated: ${providerData.id}`, { providerId: providerData.id });
  } else {
    logAuditEvent("Error", `Failed to update provider ${providerData.id}: ${result.message}`);
  }
  return result;
}

// --- Reports Functions ---

/**
 * Generic function to list generated reports, filtered by type.
 * @param {string} reportType The type of report to filter by (e.g., 'Roster', 'Enrollments').
 * @returns {object} An object containing success status and the list of reports.
 */
function listGeneratedReports(reportType) {
  try {
    const sheet = getSheet(REPORTS_SHEET_NAME, REPORTS_HEADERS);
    let allReports = sheetDataToObjects(sheet.getDataRange().getValues());

    if (reportType) {
      allReports = allReports.filter(report => report.type && report.type.toLowerCase() === reportType.toLowerCase());
    }
    
    // Sort by completion date, newest first, with in-progress items at the top
    allReports.sort((a, b) => {
      const dateA = a.completedAt ? new Date(a.completedAt) : new Date();
      const dateB = b.completedAt ? new Date(b.completedAt) : new Date();
      return dateB - dateA;
    });

    return { success: true, data: allReports };
  } catch (error) {
    logAuditEvent("Error", `Failed to list generated reports of type ${reportType}: ${error.message}`);
    return { success: false, message: `Failed to list generated reports: ${error.message}` };
  }
}

/**
 * Lists generated Sanctions and Exclusions reports.
 */
function listSanctionsAndExclusionsReports() {
  return listGeneratedReports('SanctionsAndExclusions');
}

/**
 * Lists generated Enrollments reports.
 */
function listEnrollmentsReports() {
  return listGeneratedReports('Enrollments');
}

/**
 * Lists generated Expirable Credentials reports.
 */
function listExpirableCredentialsReports() {
  return listGeneratedReports('ExpirableCredentials');
}

/**
 * Lists generated Roster reports.
 */
function listRosterReports() {
  return listGeneratedReports('Roster');
}

// --- Webhooks Functions ---

/**
 * Creates a new webhook.
 * @param {object} webhookData The data for the new webhook.
 * @returns {object} A success or error message.
 */
function createWebhook(webhookData) {
  try {
    if (!webhookData || !webhookData.url || !webhookData.type) {
      return { success: false, message: "Webhook URL and Type are required." };
    }
    const sheet = getSheet(WEBHOOKS_SHEET_NAME, WEBHOOKS_HEADERS);
    const newId = Utilities.getUuid();
    // Headers: ["ID", "Type", "URL", "Secret", "Allow Insecure URL", "Include Sensitive Info"]
    const rowData = [
      newId,
      webhookData.type,
      webhookData.url,
      webhookData.secret || "",
      webhookData.allowInsecureUrl || false,
      webhookData.includeSensitiveInfo || false
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);
    logAuditEvent("Request", `Webhook created: ${webhookData.type} for ${webhookData.url}`, { webhookId: newId });
    return { success: true, message: `Webhook created with ID: ${newId}`, data: {id: newId} };
  } catch (error) {
    logAuditEvent("Error", `Failed to create webhook: ${error.message}`);
    return { success: false, message: `Failed to create webhook: ${error.message}` };
  }
}

/**
 * Retrieves a list of all webhooks.
 * @returns {object} An object containing success status and webhooks data.
 */
function listWebhooks() {
  try {
    const sheet = getSheet(WEBHOOKS_SHEET_NAME, WEBHOOKS_HEADERS);
    const allWebhooks = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: allWebhooks };
  } catch (error) {
    logAuditEvent("Error", `Failed to list webhooks: ${error.message}`);
    return { success: false, message: `Failed to list webhooks: ${error.message}` };
  }
}

/**
 * Retrieves a specific webhook by its ID.
 * @param {string} webhookId The ID of the webhook to retrieve.
 * @returns {object} An object containing success status and webhook data.
 */
function getWebhook(webhookId) {
    try {
        if (!webhookId) {
            return { success: false, message: "Webhook ID is required." };
        }
        const sheet = getSheet(WEBHOOKS_SHEET_NAME, WEBHOOKS_HEADERS);
        const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
        const webhook = allRecords.find(record => record.id === webhookId);
        if (!webhook) {
            return { success: false, message: `Webhook with ID ${webhookId} not found.` };
        }
        return { success: true, data: webhook };
    } catch (error) {
        logAuditEvent("Error", `Failed to retrieve webhook ${webhookId}: ${error.message}`);
        return { success: false, message: `Failed to retrieve webhook: ${error.message}` };
    }
}

/**
 * Updates an existing webhook.
 * @param {string} webhookId The ID of the webhook to update.
 * @param {object} webhookData The data to patch.
 * @returns {object} A success or error message.
 */
function patchWebhook(webhookId, webhookData) {
  // Add the ID to the data object for the generic patch function
  const dataToUpdate = { ...webhookData, id: webhookId };
  const result = patchDetailedInfo(WEBHOOKS_SHEET_NAME, webhookId, dataToUpdate);
  if (result.success) {
    logAuditEvent("Request", `Webhook updated: ${webhookId}`, { webhookId: webhookId, newData: webhookData });
  } else {
    logAuditEvent("Error", `Failed to update webhook ${webhookId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a webhook record.
 * @param {string} webhookId The ID of the webhook to delete.
 * @returns {object} A success or error message.
 */
function deleteWebhook(webhookId) {
  const result = deleteDetailedProviderInfo(WEBHOOKS_SHEET_NAME, WEBHOOKS_HEADERS, webhookId);
  if (result.success) {
    // Also delete associated logs
    try {
      const logsSheet = getSheet(WEBHOOK_LOGS_SHEET_NAME, WEBHOOK_LOGS_HEADERS);
      const logIdColIndex = WEBHOOK_LOGS_HEADERS.indexOf("Webhook ID");
      deleteRowsByColumnValue(logsSheet, logIdColIndex, webhookId);
    } catch (e) {
      console.warn(`Could not delete associated logs for webhook ${webhookId}: ${e.message}`);
    }
    logAuditEvent("Request", `Webhook deleted: ${webhookId}`, { webhookId: webhookId });
  }
  return result;
}

/**
 * Retrieves a list of logs for a given webhook.
 * @param {string} webhookId The ID of the webhook to retrieve logs for.
 * @returns {object} An object containing success status and log data.
 */
function listWebhooksLog(webhookId) {
  try {
    if (!webhookId) {
      return { success: false, message: "Webhook ID is required to list logs." };
    }
    const sheet = getSheet(WEBHOOK_LOGS_SHEET_NAME, WEBHOOK_LOGS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const webhookLogs = allRecords.filter(record => record.webhookId === webhookId);
    return { success: true, data: webhookLogs };
  } catch (error) {
    logAuditEvent("Error", `Failed to list logs for webhook ${webhookId}: ${error.message}`);
    return { success: false, message: `Failed to list webhook logs: ${error.message}` };
  }
}

function deleteProvider(providerId) {
  try {
    const sheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const idColumnIndex = PROVIDERS_HEADERS.indexOf("ID");
    const rowIndex = getOrCreateRowIndex(sheet, idColumnIndex);
    const rowNum = rowIndex.get(providerId);
    if (rowNum) {
      sheet.deleteRow(rowNum);
      const associatedSheets = [
        { name: ALIASES_SHEET_NAME, headers: ALIASES_HEADERS, parentIdColName: "Provider ID" },
        { name: ADDRESSES_SHEET_NAME, headers: ADDRESSES_HEADERS, parentIdColName: "Provider ID" },
        { name: EMAILS_SHEET_NAME, headers: EMAILS_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_PROFILE_IMPORTS_SHEET_NAME, headers: PROVIDER_PROFILE_IMPORTS_HEADERS, parentIdColName: "Provider ID" },
        { name: FILES_SHEET_NAME, headers: FILES_HEADERS, parentIdColName: "Provider ID" },
        { name: LICENSES_SHEET_NAME, headers: LICENSES_HEADERS, parentIdColName: "Provider ID" },
        { name: LICENSE_VERIFICATIONS_SHEET_NAME, headers: LICENSE_VERIFICATIONS_HEADERS, parentIdColName: "Provider ID" },
        { name: DATASET_SCANS_SHEET_NAME, headers: DATASET_SCANS_HEADERS, parentIdColName: "Provider ID" },
        { name: GROUP_PROVIDERS_SHEET_NAME, headers: GROUP_PROVIDERS_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_ENROLLMENTS_SHEET_NAME, headers: PROVIDER_ENROLLMENTS_HEADERS, parentIdColName: "Provider ID" },
        { name: CREDENTIALING_REQUESTS_SHEET_NAME, headers: CREDENTIALING_REQUESTS_HEADERS, parentIdColName: "Provider ID" },
        { name: MONITORS_SHEET_NAME, headers: MONITORS_HEADERS, parentIdColName: "Provider ID" },
        { name: ALERTS_SHEET_NAME, headers: ALERTS_HEADERS, parentIdColName: "Provider ID" },
        { name: REPORTS_SHEET_NAME, headers: REPORTS_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_EDUCATION_SHEET_NAME, headers: PROVIDER_EDUCATION_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_TRAINING_SHEET_NAME, headers: PROVIDER_TRAINING_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_WORK_HISTORY_SHEET_NAME, headers: PROVIDER_WORK_HISTORY_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME, headers: PROVIDER_BOARD_CERTIFICATIONS_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_DEA_REGISTRATIONS_SHEET_NAME, headers: PROVIDER_DEA_REGISTRATIONS_HEADERS, parentIdColName: "Provider ID" },
        { name: PROVIDER_CERTIFICATES_SHEET_NAME, headers: PROVIDER_CERTIFICATES_HEADERS, parentIdColName: "Provider ID" }, // Added for Certificates
        { name: PROVIDER_CAQH_INFO_SHEET_NAME, headers: PROVIDER_CAQH_INFO_HEADERS, parentIdColName: "Provider ID" }, // Added for CAQH Info
        { name: PROVIDER_LIABILITY_INSURANCE_SHEET_NAME, headers: PROVIDER_LIABILITY_INSURANCE_HEADERS, parentIdColName: "Provider ID" }, // Added for Liability Insurance
      ];
      associatedSheets.forEach(s => {
        try {
          const currentSheet = getSheet(s.name, s.headers);
          const parentIdColIndex = s.headers.indexOf(s.parentIdColName);
          if (parentIdColIndex !== -1) deleteRowsByColumnValue(currentSheet, parentIdColIndex, providerId);
        } catch (e) {
          console.warn(`Could not delete associated data in ${s.name} for provider ${providerId}: ${e.message}`);
        }
      });
      invalidateRowIndexCache(sheet);
      logAuditEvent("Request", `Provider deleted: ${providerId}`, { providerId: providerId });
      return { success: true, message: `Provider with ID ${providerId} and associated data deleted successfully.` };
    } else {
      return { success: false, message: `Provider with ID ${providerId} not found.` };
    }
  } catch (error) {
    return { success: false, message: `Failed to delete provider: ${error.message}` };
  }
}
function getFacilityDetails(facilityId) {
  try {
    const facilitiesSheet = getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS);
    const facility = sheetDataToObjects(facilitiesSheet.getDataRange().getValues()).find(f => f.id === facilityId);
    if (!facility) {
      return { success: false, message: `Facility with ID ${facilityId} not found.` };
    }
    const relatedDataConfig = [
      // DEAs and other sub-entities were missing from this list.
      { key: 'npis', sheetName: FACILITY_NPIS_SHEET_NAME, headers: FACILITY_NPIS_HEADERS },
      { key: 'deas', sheetName: FACILITY_DEAS_SHEET_NAME, headers: FACILITY_DEAS_HEADERS },
      { key: 'liabilityInsurances', sheetName: FACILITY_LIABILITY_INSURANCE_SHEET_NAME, headers: FACILITY_LIABILITY_INSURANCE_HEADERS },
      { key: 'accreditations', sheetName: FACILITY_ACCREDITATIONS_SHEET_NAME, headers: FACILITY_ACCREDITATIONS_HEADERS },
      { key: 'cmsCertifications', sheetName: FACILITY_CMS_CERTIFICATIONS_SHEET_NAME, headers: FACILITY_CMS_CERTIFICATIONS_HEADERS },
      { key: 'alerts', sheetName: ALERTS_SHEET_NAME, headers: ALERTS_HEADERS, idField: 'facilityId' },
      { key: 'medicareEnrollments', sheetName: FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME, headers: FACILITY_MEDICARE_ENROLLMENTS_HEADERS },
      { key: 'files', sheetName: FILES_SHEET_NAME, headers: FILES_HEADERS, idField: 'facilityId' },
      { key: 'notes', sheetName: NOTES_SHEET_NAME, headers: NOTES_HEADERS, idField: 'facilityId' }
    ];
    relatedDataConfig.forEach(config => { try { const sheet = getSheet(config.sheetName, config.headers); const allRecords = sheetDataToObjects(sheet.getDataRange().getValues()); const idField = config.idField || 'facilityId'; facility[config.key] = allRecords.filter(record => record[idField] === facilityId); } catch (e) { console.warn(`Could not fetch related data from ${config.sheetName} for facility ${facilityId}: ${e.message}`); facility[config.key] = []; } });
    return { success: true, data: facility };
  } catch (error) {
    logAuditEvent("Error", `Failed to get facility details for ${facilityId}: ${error.message}`);
    return { success: false, message: `Failed to get facility details: ${error.message}` };
  }
}

function getProviderDetails(providerId) {
  try {
    // 1. Get the main provider record
    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const provider = sheetDataToObjects(providersSheet.getDataRange().getValues()).find(p => p.id === providerId);
    if (!provider) {
      return { success: false, message: `Provider with ID ${providerId} not found.` };
    }

    // 2. Get all related data
    const relatedDataConfig = [
      { key: 'aliases', sheetName: ALIASES_SHEET_NAME, headers: ALIASES_HEADERS },
      { key: 'addresses', sheetName: ADDRESSES_SHEET_NAME, headers: ADDRESSES_HEADERS },
      { key: 'emails', sheetName: EMAILS_SHEET_NAME, headers: EMAILS_HEADERS },
      { key: 'licenses', sheetName: LICENSES_SHEET_NAME, headers: LICENSES_HEADERS },
      { key: 'education', sheetName: PROVIDER_EDUCATION_SHEET_NAME, headers: PROVIDER_EDUCATION_HEADERS },
      { key: 'training', sheetName: PROVIDER_TRAINING_SHEET_NAME, headers: PROVIDER_TRAINING_HEADERS },
      { key: 'workHistory', sheetName: PROVIDER_WORK_HISTORY_SHEET_NAME, headers: PROVIDER_WORK_HISTORY_HEADERS },
      { key: 'boardCertifications', sheetName: PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME, headers: PROVIDER_BOARD_CERTIFICATIONS_HEADERS },
      { key: 'deaRegistrations', sheetName: PROVIDER_DEA_REGISTRATIONS_SHEET_NAME, headers: PROVIDER_DEA_REGISTRATIONS_HEADERS },
      { key: 'certificates', sheetName: PROVIDER_CERTIFICATES_SHEET_NAME, headers: PROVIDER_CERTIFICATES_HEADERS }, // Added for Certificates
      { key: 'caqhInfo', sheetName: PROVIDER_CAQH_INFO_SHEET_NAME, headers: PROVIDER_CAQH_INFO_HEADERS }, // Added for CAQH Info
      { key: 'liabilityInsurances', sheetName: PROVIDER_LIABILITY_INSURANCE_SHEET_NAME, headers: PROVIDER_LIABILITY_INSURANCE_HEADERS }, // Added for Liability Insurance
      { key: 'enrollments', sheetName: PROVIDER_ENROLLMENTS_SHEET_NAME, headers: PROVIDER_ENROLLMENTS_HEADERS },
      { key: 'alerts', sheetName: ALERTS_SHEET_NAME, headers: ALERTS_HEADERS, idField: 'providerId' },
      { key: 'files', sheetName: FILES_SHEET_NAME, headers: FILES_HEADERS, idField: 'providerId' }, { key: 'notes', sheetName: NOTES_SHEET_NAME, headers: NOTES_HEADERS, idField: 'providerId' }
];

    relatedDataConfig.forEach(config => {
      try {
        const sheet = getSheet(config.sheetName, config.headers);
        const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
        const idField = config.idField || 'providerId';
        provider[config.key] = allRecords.filter(record => record[idField] === providerId);
      } catch (e) {
        console.warn(`Could not fetch related data from ${config.sheetName} for provider ${providerId}: ${e.message}`);
        provider[config.key] = [];
      }
    });

    // Special enrichment for enrollments
    if (provider.enrollments && provider.enrollments.length > 0) {
        const groups = sheetDataToObjects(getSheet(GROUPS_SHEET_NAME, GROUPS_HEADERS).getDataRange().getValues());
        const plans = sheetDataToObjects(getSheet(PAYER_PLANS_SHEET_NAME, PAYER_PLANS_HEADERS).getDataRange().getValues());
        const payers = sheetDataToObjects(getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS).getDataRange().getValues());
        const groupMap = new Map(groups.map(g => [g.id, g.name]));
        const planMap = new Map(plans.map(p => [p.id, {name: p.name, payerId: p.payerId}]));
        const payerMap = new Map(payers.map(p => [p.id, p.name]));
        provider.enrollments.forEach(enrollment => { enrollment.groupName = groupMap.get(enrollment.groupId) || 'N/A'; const planInfo = planMap.get(enrollment.payerPlanId); if (planInfo) { enrollment.payerPlanName = planInfo.name || 'N/A'; enrollment.payerName = payerMap.get(planInfo.payerId) || 'N/A'; } else { enrollment.payerPlanName = 'N/A'; enrollment.payerName = 'N/A'; } });
    }
    return { success: true, data: provider };
  } catch (error) {
    logAuditEvent("Error", `Failed to get provider details for ${providerId}: ${error.message}`);
    return { success: false, message: `Failed to get provider details: ${error.message}` };
  }
}

/**
 * Retrieves the detailed information for a credentialing request, including all events,
 * checklist items, and associated provider/facility details.
 * @param {string} requestId The ID of the credentialing request.
 * @returns {object} An object containing success status and the detailed request data.
 */
function getCredentialingRequestDetails(requestId) {
  try {
    const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const allRequests = sheetDataToObjects(requestsSheet.getDataRange().getValues());
    const request = allRequests.find(r => r.id === requestId);

    if (!request) {
      return { success: false, message: `Credentialing request with ID ${requestId} not found.` };
    }

    // Fetch all events for this request
    const eventsSheet = getSheet(CREDENTIALING_REQUEST_EVENTS_SHEET_NAME, CREDENTIALING_REQUEST_EVENTS_HEADERS);
    const allEvents = sheetDataToObjects(eventsSheet.getDataRange().getValues());
    request.allEvents = allEvents.filter(e => e.requestId === requestId).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

    // Fetch all checklist items for this request
    const checklistSheet = getSheet(CREDENTIALING_CHECKLIST_ITEMS_SHEET_NAME, CREDENTIALING_CHECKLIST_ITEMS_HEADERS);
    const allChecklistItems = sheetDataToObjects(checklistSheet.getDataRange().getValues());
    request.checklist = { items: allChecklistItems.filter(item => item.requestId === requestId) };

    // Fetch associated notes
    const notesSheet = getSheet(NOTES_SHEET_NAME, NOTES_HEADERS);
    const allNotes = sheetDataToObjects(notesSheet.getDataRange().getValues());
    request.notes = allNotes.filter(note => note.requestId === requestId);

    // Enrich with provider/facility name if available
    if (request.providerId) {
      const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
      const provider = sheetDataToObjects(providersSheet.getDataRange().getValues()).find(p => p.id === request.providerId);
      request.entityName = provider ? `${provider.firstName} ${provider.lastName}` : 'Unknown Provider';
      request.entityType = 'Provider';
    } else if (request.facilityId) {
      const facilitiesSheet = getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS);
      const facility = sheetDataToObjects(facilitiesSheet.getDataRange().getValues()).find(f => f.id === request.facilityId);
      request.entityName = facility ? facility.name : 'Unknown Facility';
      request.entityType = 'Facility';
    }

    return { success: true, data: request };
  } catch (error) {
    logAuditEvent("Error", `Failed to get credentialing request details for ${requestId}: ${error.message}`);
    return { success: false, message: `Failed to get credentialing request details: ${error.message}` };
  }
}
/**
 * Reads the content of a text-based file from Google Drive.
 * This function is intended for text-readable files like .txt, .csv, .json, .html, .xml.
 * It will not return content for binary files (images, PDFs, etc.) directly.
 * @param {string} fileIdOrUrl The ID or URL of the file in Google Drive.
 * @returns {object} A success object with the file content, or an error object.
 */
function getFileContent(fileIdOrUrl) {
  try {
    let file;
    // Check if it's a full Google Drive URL
    const driveUrlMatch = fileIdOrUrl.match(/(?:id=|file\/d\/)([a-zA-Z0-9_-]+)/);
    if (driveUrlMatch && driveUrlMatch[1]) {
      file = DriveApp.getFileById(driveUrlMatch[1]);
    } else {
      // Assume it's just an ID if not a full URL
      try {
        file = DriveApp.getFileById(fileIdOrUrl);
      } catch (e) {
        // If it's not a valid Drive ID, try fetching as a generic URL
        const response = UrlFetchApp.fetch(fileIdOrUrl, {muteHttpExceptions: true});
        const contentType = response.getHeaders()['Content-Type'] || 'text/plain';
        if (contentType.startsWith('text/') || contentType.includes('json') || contentType.includes('xml')) {
            return { success: true, data: response.getContentText(), mimeType: contentType };
        } else {
            return { success: false, message: `Preview not available for external content type: ${contentType}.`, mimeType: contentType };
        }
      }
    }

    if (!file) {
      return { success: false, message: "File not found in Google Drive." };
    }

    const mimeType = file.getMimeType();
    const textMimeTypes = [
      MimeType.PLAIN_TEXT, MimeType.CSV, MimeType.HTML, MimeType.XML,
      'application/json', 'application/javascript', 'text/css', 'text/markdown'
    ];

    if (textMimeTypes.includes(mimeType) || mimeType.startsWith('text/')) {
      return { success: true, data: file.getBlob().getDataAsString(), mimeType: mimeType };
    } else {
      return { success: false, message: `Preview not available for MIME type: ${mimeType}. Try downloading the file.`, mimeType: mimeType };
    }

  } catch (e) {
    logAuditEvent("Error", `Failed to get file content for ${fileIdOrUrl}: ${e.message}`);
    return { success: false, message: `Failed to retrieve file content: ${e.message}` };
  }
}

// --- Users Functions ---
/**
 * Retrieves a list of all users.
 * @returns {object} An object containing success status and users data.
 */
function listUsers() {
  try {
    const sheet = getSheet(USERS_SHEET_NAME, USERS_HEADERS);
    const users = sheetDataToObjects(sheet.getDataRange().getValues());
    const formattedUsers = users.map(u => ({
        id: u.id,
        email: u.email,
        firstName: u.firstName,
        lastName: u.lastName,
        name: `${u.firstName} ${u.lastName}`
    }));
    return { success: true, data: formattedUsers };
  } catch (e) {
    logAuditEvent("Error", `Failed to list users: ${e.message}`);
    return { success: false, message: `Failed to list users: ${e.message}` };
  }
}

// --- Credentialing Requests (Additional) ---

/**
 * Aggregates and returns a list of unique users who own credentialing requests.
 * @returns {object} An object containing success status and a list of user objects.
 */
function aggregateCredentialingRequestOwners() {
  try {
    const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const allRequests = sheetDataToObjects(requestsSheet.getDataRange().getValues());
    
    const ownerEmails = [...new Set(allRequests.map(req => req.owner).filter(Boolean))];
    
    const allUsersResponse = listUsers();
    if (!allUsersResponse.success) {
        // Fallback to just returning emails if users can't be listed
        return { success: true, data: ownerEmails.map(email => ({ email: email })) };
    }
    
    const allUsers = allUsersResponse.data;
    const ownerUsers = allUsers.filter(user => ownerEmails.includes(user.email));

    return { success: true, data: ownerUsers };
  } catch (error) {
    logAuditEvent("Error", `Failed to aggregate credentialing request owners: ${error.message}`);
    return { success: false, message: `Failed to aggregate credentialing request owners: ${error.message}` };
  }
}

/**
 * Gets aggregations for credentialing requests, typically by status.
 * @param {object} options - Optional filters (e.g., entityType, entityDeactivated).
 * @returns {object} An object with total count and aggregations by status.
 */
function getCredentialingRequestAggregations(options = {}) {
  try {
    const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    let allRequests = sheetDataToObjects(requestsSheet.getDataRange().getValues());

    const aggregations = allRequests.reduce((acc, req) => {
      const status = req.status || 'Unknown';
      acc[status] = (acc[status] || 0) + 1;
      return acc;
    }, {});

    const total = allRequests.length;

    return { success: true, data: { total: total, aggregations: aggregations } };
  } catch (error) {
    logAuditEvent("Error", `Failed to get credentialing request aggregations: ${error.message}`);
    return { success: false, message: `Failed to get credentialing request aggregations: ${error.message}` };
  }
}

/**
 * Retrieves a specific credentialing request event by its ID.
 * @param {string} requestId The ID of the parent credentialing request.
 * @param {string} eventId The ID of the event to retrieve.
 * @returns {object} An object containing success status and the event data.
 */
function getCredentialingRequestEvent(requestId, eventId) {
  try {
    if (!requestId || !eventId) {
      return { success: false, message: "Request ID and Event ID are required." };
    }
    const sheet = getSheet(CREDENTIALING_REQUEST_EVENTS_SHEET_NAME, CREDENTIALING_REQUEST_EVENTS_HEADERS);
    const allEvents = sheetDataToObjects(sheet.getDataRange().getValues());
    
    const event = allEvents.find(e => e.requestId === requestId && e.id === eventId);

    if (!event) {
      return { success: false, message: `Event with ID ${eventId} not found for request ${requestId}.` };
    }
    return { success: true, data: event };
  } catch (error) {
    logAuditEvent("Error", `Failed to get credentialing request event ${eventId}: ${error.message}`);
    return { success: false, message: `Failed to get credentialing request event: ${error.message}` };
  }
}

/**
 * Patches an existing credentialing request with new data.
 * @param {string} requestId The ID of the credentialing request to update.
 * @param {object} requestData The data to patch (e.g., priority, ownerId, status).
 * @returns {object} A success or error message.
 */
function patchCredentialingRequest(requestId, requestData) {
  try {
    const sheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const idColIndex = CREDENTIALING_REQUESTS_HEADERS.indexOf("ID");
    const rowIndexMap = getOrCreateRowIndex(sheet, idColIndex);
    const rowNum = rowIndexMap.get(requestId);

    if (!rowNum) {
      return { success: false, message: `Credentialing request with ID ${requestId} not found.` };
    }

    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const rowValues = sheet.getRange(rowNum, 1, 1, headers.length).getValues()[0];
    let updated = false;

    // Map requestData keys to sheet headers and update values
    const headerMap = {
      priority: "Priority",
      ownerId: "Owner", // Assuming ownerId maps to "Owner" column
      status: "Status" // If you want to allow patching status directly
    };

    for (const key in requestData) {
      if (requestData.hasOwnProperty(key) && headerMap[key]) {
        const colIndex = headers.indexOf(headerMap[key]);
        if (colIndex !== -1 && rowValues[colIndex] !== requestData[key]) {
          rowValues[colIndex] = requestData[key];
          updated = true;
        }
      }
    }

    if (updated) {
      sheet.getRange(rowNum, 1, 1, headers.length).setValues([rowValues]);
      invalidateRowIndexCache(sheet);
      logAuditEvent("Request", `Credentialing request ${requestId} patched.`, { requestId: requestId, newData: requestData });
      return { success: true, message: `Credentialing request ${requestId} updated successfully.` };
    } else {
      return { success: true, message: "No changes detected for credentialing request." };
    }

  } catch (error) {
    logAuditEvent("Error", `Failed to patch credentialing request ${requestId}: ${error.message}`);
    return { success: false, message: `Failed to patch credentialing request: ${error.message}` };
  }
}

/**
 * Gathers all relevant credentialing data for a specific provider.
 * @param {string} providerId The ID of the provider.
 * @returns {object} An object containing success status and the aggregated credentialing data.
 */
function getProviderCredentialingData(providerId) {
  try {
    const providerDetails = getProviderDetails(providerId);
    if (!providerDetails.success) {
      return providerDetails;
    }
    const provider = providerDetails.data;

    const credentialingData = {
      providerInfo: {
        basicInfo: { id: provider.id, firstName: provider.firstName, lastName: provider.lastName, npi: provider.npi, credentialingStatus: provider.credentialingStatus, deactivated: provider.deactivated },
        aliases: provider.aliases, addresses: provider.addresses, emails: provider.emails, education: provider.education, training: provider.training, workHistory: provider.workHistory, boardCertifications: provider.boardCertifications, deaRegistrations: provider.deaRegistrations, certificates: provider.certificates, caqhInfo: provider.caqhInfo, liabilityInsurances: provider.liabilityInsurances
      },
      licenseVerifications: provider.licenses,
      datasetScans: sheetDataToObjects(getSheet(DATASET_SCANS_SHEET_NAME, DATASET_SCANS_HEADERS).getDataRange().getValues()).filter(s => s.providerId === providerId),
      alerts: sheetDataToObjects(getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS).getDataRange().getValues()).filter(a => a.providerId === providerId),
      files: provider.files,
      profiles: sheetDataToObjects(getSheet(PROVIDER_PROFILE_IMPORTS_SHEET_NAME, PROVIDER_PROFILE_IMPORTS_HEADERS).getDataRange().getValues()).filter(p => p.providerId === providerId)
    };

    return { success: true, data: credentialingData };
  } catch (error) {
    logAuditEvent("Error", `Failed to get provider credentialing data for ${providerId}: ${error.message}`);
    return { success: false, message: `Failed to get provider credentialing data: ${error.message}` };
  }
}

/**
 * Gathers all relevant credentialing data for a specific facility.
 * @param {string} facilityId The ID of the facility.
 * @returns {object} An object containing success status and the aggregated credentialing data.
 */
function getFacilityCredentialingData(facilityId) {
  try {
    const facilityDetails = getFacilityDetails(facilityId);
    if (!facilityDetails.success) {
      return facilityDetails;
    }
    const facility = facilityDetails.data;

    const credentialingData = {
      facility: { id: facility.id, name: facility.name, dba: facility.dba, deactivated: facility.deactivated },
      facilitySpecialties: facility.specialties,
      facilityInfo: { npis: facility.npis, deas: facility.deas, licenses: facility.licenses, accreditations: facility.accreditations, cmsCertifications: facility.cmsCertifications, medicareEnrollments: facility.medicareEnrollments, liabilityInsurances: facility.liabilityInsurances },
      childFacilities: [],
      datasetScans: sheetDataToObjects(getSheet(DATASET_SCANS_SHEET_NAME, DATASET_SCANS_HEADERS).getDataRange().getValues()).filter(s => s.facilityId === facilityId),
      alerts: sheetDataToObjects(getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS).getDataRange().getValues()).filter(a => a.facilityId === facilityId),
      files: facility.files
    };

    return { success: true, data: credentialingData };
  } catch (error) {
    logAuditEvent("Error", `Failed to get facility credentialing data for ${facilityId}: ${error.message}`);
    return { success: false, message: `Failed to get facility credentialing data: ${error.message}` };
  }
}

/**
 * Creates or replaces the entire checklist for a credentialing request.
 * @param {string} requestId The ID of the credentialing request.
 * @param {object} checklistData An object containing an array of checklist items.
 * @returns {object} A success or error message.
 */
function createCredentialingRequestChecklist(requestId, checklistData) {
  try {
    if (!requestId || !checklistData || !Array.isArray(checklistData.items)) {
      return { success: false, message: "Request ID and a valid checklist items array are required." };
    }
    
    const sheet = getSheet(CREDENTIALING_CHECKLIST_ITEMS_SHEET_NAME, CREDENTIALING_CHECKLIST_ITEMS_HEADERS);
    const requestIdColIndex = CREDENTIALING_CHECKLIST_ITEMS_HEADERS.indexOf("Request ID");

    deleteRowsByColumnValue(sheet, requestIdColIndex, requestId);

    const newRows = checklistData.items.map(item => [
      Utilities.getUuid(), requestId, item.name || "", item.status || "Pending", item.confirmedAt || "", item.confirmedBy || "", item.verifiedAt || "", item.source || "", JSON.stringify(item.references || {})
    ]);

    if (newRows.length > 0) {
      sheet.getRange(sheet.getLastRow() + 1, 1, newRows.length, newRows[0].length).setValues(newRows);
    }
    
    invalidateRowIndexCache(sheet);
    logAuditEvent("Request", `Checklist created/replaced for request ${requestId}`, { requestId: requestId, itemCount: newRows.length });
    return { success: true, message: `Checklist for request ${requestId} has been successfully updated.` };
  } catch (error) {
    logAuditEvent("Error", `Failed to create/replace checklist for request ${requestId}: ${error.message}`);
    return { success: false, message: `Failed to create/replace checklist: ${error.message}` };
  }
}

// --- Provider Aliases Functions ---

/**
 * Creates a new provider alias record.
 * @param {string} providerId The ID of the provider the alias belongs to.
 * @param {object} aliasData The data for the new alias (firstName, lastName).
 * @returns {object} A success or error message.
 */
function createProviderAliasInfo(providerId, aliasData) {
  if (!providerId || !aliasData || !aliasData.firstName || !aliasData.lastName) {
    return { success: false, message: "Provider ID, first name, and last name are required." };
  }
  const rowData = [aliasData.firstName, aliasData.lastName];
  return createSubEntity(
    ALIASES_SHEET_NAME,
    ALIASES_HEADERS,
    providerId,
    rowData,
    `Alias "${aliasData.firstName} ${aliasData.lastName}"`
  );
}
/**
 * Retrieves a list of aliases for a given provider.
 * @param {string} providerId The ID of the provider to retrieve aliases for.
 * @returns {object} An object containing success status and alias data.
 */
function listProviderAliasInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list aliases." };
    }
    const sheet = getSheet(ALIASES_SHEET_NAME, ALIASES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerAliases = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerAliases };
  } catch (error) {
    return { success: false, message: `Failed to list provider aliases: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider alias by its ID and provider ID.
 * @param {string} providerId The ID of the provider the alias belongs to.
 * @param {string} aliasId The ID of the alias to retrieve.
 * @returns {object} An object containing success status and alias data.
 */
function getProviderAliasInfo(providerId, aliasId) {
  try {
    if (!providerId || !aliasId) {
      return { success: false, message: "Provider ID and Alias ID are required to get alias details." };
    }
    const sheet = getSheet(ALIASES_SHEET_NAME, ALIASES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const alias = allRecords.find(record => record.providerId === providerId && record.id === aliasId);
    if (!alias) {
      return { success: false, message: `Alias with ID ${aliasId} not found for provider ${providerId}.` };
    }
    return { success: true, data: alias };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider alias details: ${error.message}` };
  }
}

/**
 * Updates an existing provider alias.
 * @param {string} aliasId The ID of the alias to update.
 * @param {object} aliasData The data to patch (e.g., firstName, lastName).
 * @returns {object} A success or error message.
 */
function putProviderAliasInfo(aliasId, aliasData) {
  // Using patchDetailedInfo for a generic update, assuming aliasData includes the ID.
  // Note: For 'put' semantic, it usually means full replacement. If only partial updates are intended, 'patch' is more appropriate.
  // The provided API script uses 'put' for this, implying full replacement or creation if not exists.
  // For simplicity and alignment with existing patch helpers, we'll treat it as a patch here.
  const result = patchDetailedInfo(ALIASES_SHEET_NAME, aliasId, aliasData);
  if (result.success) {
    logAuditEvent("Request", `Provider alias updated: ${aliasId}`, { aliasId: aliasId, newData: aliasData });
  } else {
    logAuditEvent("Error", `Failed to update provider alias ${aliasId}: ${result.message}`);
  }
  return result;
}

// --- File Management Functions ---

/**
 * Uploads a file to Google Drive and links it to a provider.
 * This function is called from the frontend.
 * @param {object} fileObject An object containing file details {fileName, mimeType, data}.
 * @param {string} providerId The ID of the provider to link the file to.
 * @returns {object} A success or error message.
 */
function uploadFileAndLinkToProvider(fileObject, providerId) {
  try {
    if (!fileObject || !providerId) {
      return { success: false, message: "File data and provider ID are required." };
    }
    
    const folder = getUploadFolder();
    const dataUrlParts = fileObject.data.split(',');
    const mimeType = dataUrlParts[0].match(/:(.*?);/)[1];
    const base64Data = dataUrlParts[1];
    const decodedData = Utilities.base64Decode(base64Data);
    const blob = Utilities.newBlob(decodedData, mimeType, fileObject.fileName);
    
    const file = folder.createFile(blob);
    const fileUrl = file.getUrl();
    const fileSize = file.getSize();
    const userEmail = Session.getActiveUser().getEmail();

    const filesSheet = getSheet(FILES_SHEET_NAME, FILES_HEADERS);
    const newId = Utilities.getUuid();
    // Headers: ["ID", "Path", "Provider ID", "Facility ID", "Created At", "Created By User ID", "Created By User Email", "Size"]
    filesSheet.appendRow([newId, fileUrl, providerId, "", new Date().toISOString(), "", userEmail, fileSize]);
    invalidateRowIndexCache(filesSheet);

    logAuditEvent("Request", `File uploaded for provider ${providerId}: ${fileObject.fileName}`, { providerId: providerId, fileId: newId, path: fileUrl });
    return { success: true, message: `File "${fileObject.fileName}" uploaded and linked to provider.` };
  } catch (e) {
    logAuditEvent("Error", `File upload for provider ${providerId} failed: ${e.message}`);
    return { success: false, message: `File upload failed: ${e.message}` };
  }
}

/**
 * Uploads a file to Google Drive and links it to a facility.
 * @param {object} fileObject An object containing file details {fileName, mimeType, data}.
 * @param {string} facilityId The ID of the facility to link the file to.
 * @returns {object} A success or error message.
 */
function uploadFileAndLinkToFacility(fileObject, facilityId) {
  try {
    if (!fileObject || !facilityId) {
      return { success: false, message: "File data and facility ID are required." };
    }
    
    const folder = getUploadFolder();
    const dataUrlParts = fileObject.data.split(',');
    const mimeType = dataUrlParts[0].match(/:(.*?);/)[1];
    const base64Data = dataUrlParts[1];
    const decodedData = Utilities.base64Decode(base64Data);
    const blob = Utilities.newBlob(decodedData, mimeType, fileObject.fileName);
    
    const file = folder.createFile(blob);
    const fileUrl = file.getUrl();
    const fileSize = file.getSize();
    const userEmail = Session.getActiveUser().getEmail();

    const filesSheet = getSheet(FILES_SHEET_NAME, FILES_HEADERS);
    const newId = Utilities.getUuid();
    // Headers: ["ID", "Path", "Provider ID", "Facility ID", "Created At", "Created By User ID", "Created By User Email", "Size"]
    filesSheet.appendRow([newId, fileUrl, "", facilityId, new Date().toISOString(), "", userEmail, fileSize]);
    invalidateRowIndexCache(filesSheet);

    logAuditEvent("Request", `File uploaded for facility ${facilityId}: ${fileObject.fileName}`, { facilityId: facilityId, fileId: newId, path: fileUrl });
    return { success: true, message: `File "${fileObject.fileName}" uploaded and linked to facility.` };
  } catch (e) {
    logAuditEvent("Error", `File upload for facility ${facilityId} failed: ${e.message}`);
    return { success: false, message: `File upload failed: ${e.message}` };
  }
}

/**
 * Creates a new credentialing request.
 * @param {object} requestData The data for the new request.
 * @returns {object} A success or error message, with the new request data on success.
 */
function createCredentialingRequest(requestData) {
  try {
    if (!requestData.providerId && !requestData.facilityId) {
      return { success: false, message: "Provider ID or Facility ID is required." };
    }

    const sheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const newId = Utilities.getUuid();
    const now = new Date().toISOString();
    const userEmail = Session.getActiveUser().getEmail();
    const status = "RequestSubmitted";

    const newRequest = {
      id: newId,
      providerId: requestData.providerId || "",
      facilityId: requestData.facilityId || "",
      type: requestData.type || "Initial",
      priority: requestData.priority || "Medium",
      status: status,
      owner: userEmail,
      createdAt: now,
      currentEvent: {}
    };

    const eventData = { note: "Initial request created.", status: status, attachments: [] };
    const eventResponse = createCredentialingRequestEvent(newId, eventData);
    if (!eventResponse.success) {
      throw new Error(`Failed to create initial event for request: ${eventResponse.message}`);
    }
    newRequest.currentEvent = eventResponse.data;

    const rowData = [
      newRequest.id, newRequest.providerId, newRequest.facilityId, newRequest.type,
      newRequest.priority, newRequest.status, newRequest.owner, newRequest.createdAt,
      JSON.stringify(newRequest.currentEvent)
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    logAuditEvent("Request", `Credentialing request created: ${newId}`, { requestId: newId, providerId: newRequest.providerId, facilityId: newRequest.facilityId });
    return { success: true, message: `Credentialing request created with ID: ${newId}`, data: newRequest };
  } catch (error) {
    logAuditEvent("Error", `Failed to create credentialing request: ${error.message}`);
    return { success: false, message: `Failed to create credentialing request: ${error.message}` };
  }
}

/**
 * Creates a new event for a credentialing request.
 * @param {string} requestId The ID of the credentialing request.
 * @param {object} eventData The data for the new event.
 * @returns {object} A success or error message, with the new event data on success.
 */
function createCredentialingRequestEvent(requestId, eventData) {
  try {
    const sheet = getSheet(CREDENTIALING_REQUEST_EVENTS_SHEET_NAME, CREDENTIALING_REQUEST_EVENTS_HEADERS);
    const newId = Utilities.getUuid();
    const now = new Date().toISOString();
    const userEmail = Session.getActiveUser().getEmail();

    const newEvent = {
      id: newId,
      requestId: requestId,
      timestamp: now,
      status: eventData.status,
      note: eventData.note || "",
      user: userEmail,
      attachments: eventData.attachments || []
    };

    const rowData = [ newEvent.id, newEvent.requestId, newEvent.timestamp, newEvent.status, newEvent.note, newEvent.user, JSON.stringify(newEvent.attachments) ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const idColIndex = CREDENTIALING_REQUESTS_HEADERS.indexOf("ID");
    const rowIndexMap = getOrCreateRowIndex(requestsSheet, idColIndex);
    const rowNum = rowIndexMap.get(requestId);
    if (rowNum) {
      requestsSheet.getRange(rowNum, CREDENTIALING_REQUESTS_HEADERS.indexOf("Status") + 1).setValue(newEvent.status);
      requestsSheet.getRange(rowNum, CREDENTIALING_REQUESTS_HEADERS.indexOf("Current Event (JSON)") + 1).setValue(JSON.stringify(newEvent));
    }

    logAuditEvent("Request", `Credentialing event created for request ${requestId}`, { requestId: requestId, eventId: newId, status: newEvent.status });
    return { success: true, message: "Event created successfully.", data: newEvent };
  } catch (error) {
    logAuditEvent("Error", `Failed to create credentialing event for request ${requestId}: ${error.message}`);
    return { success: false, message: `Failed to create credentialing event: ${error.message}` };
  }
}

// --- Integrations Functions ---

/**
 * Handles a webhook from Fountain. Creates a provider and a credentialing request.
 * @param {string} organizationId The ID of the organization (not used in this implementation).
 * @param {object} body The webhook payload from Fountain.
 * @returns {object} A response object with the created credentialing request ID.
 */
function fountainWebhook(organizationId, body) {
  try {
    const applicant = body.applicant;
    if (!applicant || !applicant.email || !applicant.first_name || !applicant.last_name) {
      return { success: false, message: "Invalid Fountain webhook payload. Applicant data is missing." };
    }

    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
    let provider = allProviders.find(p => p.emails && p.emails.some(e => e.email === applicant.email));
    let providerId;

    if (provider) {
      providerId = provider.id;
      logAuditEvent("System", `Fountain webhook: Found existing provider by email ${applicant.email}`, { providerId: providerId, fountainApplicantId: applicant.id });
    } else {
      const providerData = { firstName: applicant.first_name, lastName: applicant.last_name, credentialingStatus: "Data Collection", deactivated: false };
      const createProviderResponse = createProvider(providerData);
      if (!createProviderResponse.success) {
        throw new Error(`Failed to create provider from Fountain webhook: ${createProviderResponse.message}`);
      }
      const newProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
      const newProvider = newProviders.find(p => p.firstName === applicant.first_name && p.lastName === applicant.last_name && !allProviders.some(ap => ap.id === p.id));
      if (!newProvider) throw new Error("Could not find the newly created provider.");
      providerId = newProvider.id;

      createProviderEmailInfo(providerId, { email: applicant.email, type: 'Personal' });
      logAuditEvent("System", `Fountain webhook: Created new provider ${providerId} for ${applicant.email}`, { providerId: providerId, fountainApplicantId: applicant.id });
    }

    const requestData = { providerId: providerId, type: 'Initial', priority: 'Medium' };
    const createRequestResponse = createCredentialingRequest(requestData);
    if (!createRequestResponse.success) {
      throw new Error(`Failed to create credentialing request for provider ${providerId}: ${createRequestResponse.message}`);
    }
    
    const requestId = createRequestResponse.data.id;
    logAuditEvent("System", `Fountain webhook: Created credentialing request ${requestId} for provider ${providerId}`, { providerId: providerId, requestId: requestId });

    return { success: true, requestId: requestId };

  } catch (error) {
    logAuditEvent("Error", `Fountain webhook processing failed: ${error.message}`, { payload: body });
    return { success: false, message: `Fountain webhook processing failed: ${error.message}` };
  }
}

/**
 * Handles a document request from Salesforce. Uploads a file and links it to entities.
 * @param {object} body The request payload from Salesforce.
 * @returns {object} A success or error message.
 */
function salesforceDocumentRequest(body) {
  try {
    if (!body || !body.document || !body.relatedIds || body.relatedIds.length === 0) {
      return { success: false, message: "Invalid Salesforce document request. Document and relatedIds are required." };
    }

    const fileName = body.pathOnClient || `salesforce-upload-${new Date().getTime()}.dat`;
    const mimeType = MimeType.lookup(fileName) || 'application/octet-stream';
    const dataUrl = `data:${mimeType};base64,${body.document}`;
    const fileObject = { fileName: fileName, mimeType: mimeType, data: dataUrl };

    let linkedCount = 0;
    const errors = [];

    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const facilitiesSheet = getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS);
    const providerIds = new Set(providersSheet.getRange(2, 1, providersSheet.getLastRow() - 1, 1).getValues().flat());
    const facilityIds = new Set(facilitiesSheet.getRange(2, 1, facilitiesSheet.getLastRow() - 1, 1).getValues().flat());

    body.relatedIds.forEach(id => {
      let result;
      if (providerIds.has(id)) {
        result = uploadFileAndLinkToProvider(fileObject, id);
      } else if (facilityIds.has(id)) {
        result = uploadFileAndLinkToFacility(fileObject, id);
      } else {
        result = { success: false, message: `Entity with ID ${id} not found.` };
      }

      if (result.success) {
        linkedCount++;
      } else {
        errors.push(`ID ${id}: ${result.message}`);
      }
    });

    if (linkedCount > 0) {
      logAuditEvent("System", `Salesforce document request processed. Linked to ${linkedCount} entities.`, { relatedIds: body.relatedIds, fileName: fileName });
      return { success: true, message: `Document linked to ${linkedCount} entities. Errors: ${errors.join(', ')}` };
    } else {
      throw new Error(`Failed to link document to any entities. Errors: ${errors.join(', ')}`);
    }
  } catch (error) {
    logAuditEvent("Error", `Salesforce document request failed: ${error.message}`, { payload: body });
    return { success: false, message: `Salesforce document request failed: ${error.message}` };
  }
}

const MimeType = {
  lookup: (filename) => {
    const extension = filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
    const types = {
      'pdf': 'application/pdf', 'doc': 'application/msword', 'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'xls': 'application/vnd.ms-excel', 'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'ppt': 'application/vnd.ms-powerpoint', 'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 'gif': 'image/gif',
      'txt': 'text/plain', 'csv': 'text/csv', 'html': 'text/html', 'xml': 'application/xml'
    };
    return types[extension] || null;
  }
};

/**
 * Deletes a provider alias record.
 * @param {string} aliasId The ID of the alias to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderAliasInfo(aliasId) {
  const result = deleteDetailedProviderInfo(ALIASES_SHEET_NAME, ALIASES_HEADERS, aliasId);
  if (result.success) {
    logAuditEvent("Request", `Provider alias deleted: ${aliasId}`, { aliasId: aliasId });
  }
  return result;
}

// --- Provider Addresses Functions ---

/**
 * Creates a new provider address record.
 * @param {string} providerId The ID of the provider the address belongs to.
 * @param {object} addressData The data for the new address (addressLine1, city, state, zipCode, type).
 * @returns {object} A success or error message.
 */
function createProviderAddressInfo(providerId, addressData) {
  if (!providerId || !addressData || !addressData.addressLine1 || !addressData.city || !addressData.state || !addressData.zipCode) {
    return { success: false, message: "Provider ID, address line 1, city, state, and zip code are required." };
  }
  const rowData = [
    addressData.addressLine1,
    addressData.addressLine2 || "",
    addressData.city,
    addressData.state,
    addressData.zipCode,
    addressData.type || "Unspecified"
  ];
  return createSubEntity(
    ADDRESSES_SHEET_NAME,
    ADDRESSES_HEADERS,
    providerId,
    rowData,
    `Address "${addressData.addressLine1}"`
  );
}

/**
 * Retrieves a list of addresses for a given provider.
 * @param {string} providerId The ID of the provider to retrieve addresses for.
 * @returns {object} An object containing success status and address data.
 */
function listProviderAddressInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list addresses." };
    }
    const sheet = getSheet(ADDRESSES_SHEET_NAME, ADDRESSES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerAddresses = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerAddresses };
  } catch (error) {
    return { success: false, message: `Failed to list provider addresses: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider address by its ID and provider ID.
 * @param {string} providerId The ID of the provider the address belongs to.
 * @param {string} addressId The ID of the address to retrieve.
 * @returns {object} An object containing success status and address data.
 */
function getProviderAddressInfo(providerId, addressId) {
  try {
    if (!providerId || !addressId) {
      return { success: false, message: "Provider ID and Address ID are required to get address details." };
    }
    const sheet = getSheet(ADDRESSES_SHEET_NAME, ADDRESSES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const address = allRecords.find(record => record.providerId === providerId && record.id === addressId);
    if (!address) {
      return { success: false, message: `Address with ID ${addressId} not found for provider ${providerId}.` };
    }
    return { success: true, data: address };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider address details: ${error.message}` };
  }
}

/**
 * Updates an existing provider address.
 * @param {string} addressId The ID of the address to update.
 * @param {object} addressData The data to patch (e.g., addressLine1, city, state, zipCode, type).
 * @returns {object} A success or error message.
 */
function putProviderAddressInfo(addressId, addressData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(ADDRESSES_SHEET_NAME, addressId, addressData);
  if (result.success) {
    logAuditEvent("Request", `Provider address updated: ${addressId}`, { addressId: addressId, newData: addressData });
  } else {
    logAuditEvent("Error", `Failed to update provider address ${addressId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider address record.
 * @param {string} addressId The ID of the address to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderAddressInfo(addressId) {
  const result = deleteDetailedProviderInfo(ADDRESSES_SHEET_NAME, ADDRESSES_HEADERS, addressId);
  if (result.success) {
    logAuditEvent("Request", `Provider address deleted: ${addressId}`, { addressId: addressId });
  }
  return result;
}

// --- Provider Emails Functions ---

/**
 * Creates a new provider email record.
 * @param {string} providerId The ID of the provider the email belongs to.
 * @param {object} emailData The data for the new email (email, type).
 * @returns {object} A success or error message.
 */
function createProviderEmailInfo(providerId, emailData) {
  if (!providerId || !emailData || !emailData.email) {
    return { success: false, message: "Provider ID and email address are required." };
  }
  const rowData = [emailData.email, emailData.type || "Unspecified"];
  return createSubEntity(
    EMAILS_SHEET_NAME,
    EMAILS_HEADERS,
    providerId,
    rowData,
    `Email "${emailData.email}"`
  );
}

/**
 * Retrieves a list of emails for a given provider.
 * @param {string} providerId The ID of the provider to retrieve emails for.
 * @returns {object} An object containing success status and email data.
 */
function listProviderEmailInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list emails." };
    }
    const sheet = getSheet(EMAILS_SHEET_NAME, EMAILS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerEmails = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerEmails };
  } catch (error) {
    return { success: false, message: `Failed to list provider emails: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider email by its ID and provider ID.
 * @param {string} providerId The ID of the provider the email belongs to.
 * @param {string} emailId The ID of the email to retrieve.
 * @returns {object} An object containing success status and email data.
 */
function getProviderEmailInfo(providerId, emailId) {
  try {
    if (!providerId || !emailId) {
      return { success: false, message: "Provider ID and Email ID are required to get email details." };
    }
    const sheet = getSheet(EMAILS_SHEET_NAME, EMAILS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const email = allRecords.find(record => record.providerId === providerId && record.id === emailId);
    if (!email) {
      return { success: false, message: `Email with ID ${emailId} not found for provider ${providerId}.` };
    }
    return { success: true, data: email };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider email details: ${error.message}` };
  }
}

/**
 * Updates an existing provider email.
 * @param {string} emailId The ID of the email to update.
 * @param {object} emailData The data to patch (e.g., email, type).
 * @returns {object} A success or error message.
 */
function putProviderEmailInfo(emailId, emailData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(EMAILS_SHEET_NAME, emailId, emailData);
  if (result.success) {
    logAuditEvent("Request", `Provider email updated: ${emailId}`, { emailId: emailId, newData: emailData });
  } else {
    logAuditEvent("Error", `Failed to update provider email ${emailId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider email record.
 * @param {string} emailId The ID of the email to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderEmailInfo(emailId) {
  const result = deleteDetailedProviderInfo(EMAILS_SHEET_NAME, EMAILS_HEADERS, emailId);
  if (result.success) {
    logAuditEvent("Request", `Provider email deleted: ${emailId}`, { emailId: emailId });
  }
  return result;
}

// --- Provider Education Functions ---

/**
 * Creates a new provider education record.
 * @param {string} providerId The ID of the provider the education belongs to.
 * @param {object} educationData The data for the new education record (schoolName, degree, graduateType, startDate, endDate).
 * @returns {object} A success or error message.
 */
function createProviderEducationInfo(providerId, educationData) {
  if (!providerId || !educationData || !educationData.schoolName || !educationData.degree) {
    return { success: false, message: "Provider ID, school name, and degree are required." };
  }
  const rowData = [
      educationData.schoolName,
      educationData.degree,
      educationData.graduateType || "",
      educationData.startDate || "",
      educationData.endDate || ""
  ];
  return createSubEntity(
    PROVIDER_EDUCATION_SHEET_NAME,
    PROVIDER_EDUCATION_HEADERS,
    providerId,
    rowData,
    `Education record for "${educationData.schoolName}"`
  );
}

/**
 * Retrieves a list of education records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve education records for.
 * @returns {object} An object containing success status and education data.
 */
function listProviderEducationInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list education records." };
    }
    const sheet = getSheet(PROVIDER_EDUCATION_SHEET_NAME, PROVIDER_EDUCATION_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerEducationRecords = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerEducationRecords };
  } catch (error) {
    return { success: false, message: `Failed to list provider education records: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider education record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the education belongs to.
 * @param {string} educationId The ID of the education record to retrieve.
 * @returns {object} An object containing success status and education data.
 */
function getProviderEducationInfo(providerId, educationId) {
  try {
    if (!providerId || !educationId) {
      return { success: false, message: "Provider ID and Education ID are required to get education details." };
    }
    const sheet = getSheet(PROVIDER_EDUCATION_SHEET_NAME, PROVIDER_EDUCATION_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const education = allRecords.find(record => record.providerId === providerId && record.id === educationId);
    if (!education) {
      return { success: false, message: `Education record with ID ${educationId} not found for provider ${providerId}.` };
    }
    return { success: true, data: education };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider education details: ${error.message}` };
  }
}

/**
 * Updates an existing provider education record.
 * @param {string} educationId The ID of the education record to update.
 * @param {object} educationData The data to patch (e.g., schoolName, degree, graduateType, startDate, endDate).
 * @returns {object} A success or error message.
 */
function patchProviderEducationInfo(educationId, educationData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_EDUCATION_SHEET_NAME, educationId, educationData);
  if (result.success) {
    logAuditEvent("Request", `Provider education updated: ${educationId}`, { educationId: educationId, newData: educationData });
  } else {
    logAuditEvent("Error", `Failed to update provider education ${educationId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider education record.
 * @param {string} educationId The ID of the education record to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderEducationInfo(educationId) {
  const result = deleteDetailedProviderInfo(PROVIDER_EDUCATION_SHEET_NAME, PROVIDER_EDUCATION_HEADERS, educationId);
  if (result.success) {
    logAuditEvent("Request", `Provider education deleted: ${educationId}`, { educationId: educationId });
  }
  return result;
}

// --- Provider Training Functions ---

/**
 * Creates a new provider training record.
 * @param {string} providerId The ID of the provider the training belongs to.
 * @param {object} trainingData The data for the new training record (institutionName, speciality, trainingType, startDate, endDate).
 * @returns {object} A success or error message.
 */
function createProviderTrainingInfo(providerId, trainingData) {
  if (!providerId || !trainingData || !trainingData.institutionName || !trainingData.speciality) {
    return { success: false, message: "Provider ID, institution name, and speciality are required." };
  }
  const rowData = [
      trainingData.institutionName,
      trainingData.speciality,
      trainingData.trainingType || "",
      trainingData.startDate || "",
      trainingData.endDate || ""
  ];
  return createSubEntity(
    PROVIDER_TRAINING_SHEET_NAME,
    PROVIDER_TRAINING_HEADERS,
    providerId,
    rowData,
    `Training record for "${trainingData.institutionName}"`
  );
}

/**
 * Retrieves a list of training records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve training records for.
 * @returns {object} An object containing success status and training data.
 */
function listProviderTrainingInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list training records." };
    }
    const sheet = getSheet(PROVIDER_TRAINING_SHEET_NAME, PROVIDER_TRAINING_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerTrainingRecords = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerTrainingRecords };
  } catch (error) {
    return { success: false, message: `Failed to list provider training records: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider training record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the training belongs to.
 * @param {string} trainingId The ID of the training record to retrieve.
 * @returns {object} An object containing success status and training data.
 */
function getProviderTrainingInfo(providerId, trainingId) {
  try {
    if (!providerId || !trainingId) {
      return { success: false, message: "Provider ID and Training ID are required to get training details." };
    }
    const sheet = getSheet(PROVIDER_TRAINING_SHEET_NAME, PROVIDER_TRAINING_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const training = allRecords.find(record => record.providerId === providerId && record.id === trainingId);
    if (!training) {
      return { success: false, message: `Training record with ID ${trainingId} not found for provider ${providerId}.` };
    }
    return { success: true, data: training };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider training details: ${error.message}` };
  }
}

/**
 * Updates an existing provider training record.
 * @param {string} trainingId The ID of the training record to update.
 * @param {object} trainingData The data to patch (e.g., institutionName, speciality, trainingType, startDate, endDate).
 * @returns {object} A success or error message.
 */
function patchProviderTrainingInfo(trainingId, trainingData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_TRAINING_SHEET_NAME, trainingId, trainingData);
  if (result.success) {
    logAuditEvent("Request", `Provider training updated: ${trainingId}`, { trainingId: trainingId, newData: trainingData });
  } else {
    logAuditEvent("Error", `Failed to update provider training ${trainingId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider training record.
 * @param {string} trainingId The ID of the training record to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderTrainingInfo(trainingId) {
  const result = deleteDetailedProviderInfo(PROVIDER_TRAINING_SHEET_NAME, PROVIDER_TRAINING_HEADERS, trainingId);
  if (result.success) {
    logAuditEvent("Request", `Provider training deleted: ${trainingId}`, { trainingId: trainingId });
  }
  return result;
}

// --- Provider Work History Functions ---

/**
 * Creates a new provider work history record.
 * @param {string} providerId The ID of the provider the work history belongs to.
 * @param {object} workHistoryData The data for the new work history record (name, jobTitle, startDate, endDate, isCurrentEmployer).
 * @returns {object} A success or error message.
 */
function createProviderWorkHistoryInfo(providerId, workHistoryData) {
  if (!providerId || !workHistoryData || !workHistoryData.name || !workHistoryData.jobTitle) {
    return { success: false, message: "Provider ID, employer name, and job title are required." };
  }
  const rowData = [
      workHistoryData.name,
      workHistoryData.jobTitle,
      workHistoryData.startDate || "",
      workHistoryData.endDate || "",
      workHistoryData.isCurrentEmployer || false
  ];
  return createSubEntity(
    PROVIDER_WORK_HISTORY_SHEET_NAME,
    PROVIDER_WORK_HISTORY_HEADERS,
    providerId,
    rowData,
    `Work history record for "${workHistoryData.name}"`
  );
}

/**
 * Retrieves a list of work history records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve work history records for.
 * @returns {object} An object containing success status and work history data.
 */
function listProviderWorkHistoryInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list work history records." };
    }
    const sheet = getSheet(PROVIDER_WORK_HISTORY_SHEET_NAME, PROVIDER_WORK_HISTORY_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerWorkHistoryRecords = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerWorkHistoryRecords };
  } catch (error) {
    return { success: false, message: `Failed to list provider work history records: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider work history record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the work history belongs to.
 * @param {string} workHistoryId The ID of the work history record to retrieve.
 * @returns {object} An object containing success status and work history data.
 */
function getProviderWorkHistoryInfo(providerId, workHistoryId) {
  try {
    if (!providerId || !workHistoryId) {
      return { success: false, message: "Provider ID and Work History ID are required to get work history details." };
    }
    const sheet = getSheet(PROVIDER_WORK_HISTORY_SHEET_NAME, PROVIDER_WORK_HISTORY_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const workHistory = allRecords.find(record => record.providerId === providerId && record.id === workHistoryId);
    if (!workHistory) {
      return { success: false, message: `Work history record with ID ${workHistoryId} not found for provider ${providerId}.` };
    }
    return { success: true, data: workHistory };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider work history details: ${error.message}` };
  }
}

/**
 * Updates an existing provider work history record.
 * @param {string} workHistoryId The ID of the work history record to update.
 * @param {object} workHistoryData The data to patch (e.g., name, jobTitle, startDate, endDate, isCurrentEmployer).
 * @returns {object} A success or error message.
 */
function patchProviderWorkHistoryInfo(workHistoryId, workHistoryData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_WORK_HISTORY_SHEET_NAME, workHistoryId, workHistoryData);
  if (result.success) {
    logAuditEvent("Request", `Provider work history updated: ${workHistoryId}`, { workHistoryId: workHistoryId, newData: workHistoryData });
  } else {
    logAuditEvent("Error", `Failed to update provider work history ${workHistoryId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider work history record.
 * @param {string} workHistoryId The ID of the work history record to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderWorkHistoryInfo(workHistoryId) {
  const result = deleteDetailedProviderInfo(PROVIDER_WORK_HISTORY_SHEET_NAME, PROVIDER_WORK_HISTORY_HEADERS, workHistoryId);
  if (result.success) {
    logAuditEvent("Request", `Provider work history deleted: ${workHistoryId}`, { workHistoryId: workHistoryId });
  }
  return result;
}

// --- Provider DEA Registrations Functions ---

/**
 * Creates a new provider DEA registration record.
 * @param {string} providerId The ID of the provider the DEA registration belongs to.
 * @param {object} deaRegistrationData The data for the new DEA registration (registrationNumber, lastUpdatedAt).
 * @returns {object} A success or error message.
 */
function createDeaRegistrationInfo(providerId, deaRegistrationData) {
  if (!providerId || !deaRegistrationData || !deaRegistrationData.registrationNumber) {
    return { success: false, message: "Provider ID and registration number are required." };
  }
  const rowData = [
      deaRegistrationData.registrationNumber,
      deaRegistrationData.lastUpdatedAt || new Date().toISOString()
  ];
  return createSubEntity(
    PROVIDER_DEA_REGISTRATIONS_SHEET_NAME,
    PROVIDER_DEA_REGISTRATIONS_HEADERS,
    providerId,
    rowData,
    `DEA Registration "${deaRegistrationData.registrationNumber}"`
  );
}

/**
 * Retrieves a list of DEA registration records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve DEA registration records for.
 * @returns {object} An object containing success status and DEA registration data.
 */
function listDeaRegistrationInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list DEA registrations." };
    }
    const sheet = getSheet(PROVIDER_DEA_REGISTRATIONS_SHEET_NAME, PROVIDER_DEA_REGISTRATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerDeaRegistrations = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerDeaRegistrations };
  } catch (error) {
    return { success: false, message: `Failed to list provider DEA registrations: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider DEA registration record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the DEA registration belongs to.
 * @param {string} deaRegistrationId The ID of the DEA registration record to retrieve.
 * @returns {object} An object containing success status and DEA registration data.
 */
function getDeaRegistrationInfo(providerId, deaRegistrationId) {
  try {
    if (!providerId || !deaRegistrationId) {
      return { success: false, message: "Provider ID and DEA Registration ID are required to get DEA registration details." };
    }
    const sheet = getSheet(PROVIDER_DEA_REGISTRATIONS_SHEET_NAME, PROVIDER_DEA_REGISTRATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const deaRegistration = allRecords.find(record => record.providerId === providerId && record.id === deaRegistrationId);
    if (!deaRegistration) {
      return { success: false, message: `DEA Registration with ID ${deaRegistrationId} not found for provider ${providerId}.` };
    }
    return { success: true, data: deaRegistration };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider DEA registration details: ${error.message}` };
  }
}

/**
 * Updates an existing provider DEA registration record.
 * @param {string} deaRegistrationId The ID of the DEA registration record to update.
 * @param {object} deaRegistrationData The data to patch (e.g., registrationNumber, lastUpdatedAt).
 * @returns {object} A success or error message.
 */
function patchDeaRegistrationInfo(deaRegistrationId, deaRegistrationData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_DEA_REGISTRATIONS_SHEET_NAME, deaRegistrationId, deaRegistrationData);
  if (result.success) {
    logAuditEvent("Request", `Provider DEA registration updated: ${deaRegistrationId}`, { deaRegistrationId: deaRegistrationId, newData: deaRegistrationData });
  } else {
    logAuditEvent("Error", `Failed to update provider DEA registration ${deaRegistrationId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider DEA registration record.
 * @param {string} deaRegistrationId The ID of the DEA registration record to delete.
 * @returns {object} A success or error message.
 */
function deleteDeaRegistrationInfo(deaRegistrationId) {
  const result = deleteDetailedProviderInfo(PROVIDER_DEA_REGISTRATIONS_SHEET_NAME, PROVIDER_DEA_REGISTRATIONS_HEADERS, deaRegistrationId);
  if (result.success) {
    logAuditEvent("Request", `Provider DEA registration deleted: ${deaRegistrationId}`, { deaRegistrationId: deaRegistrationId });
  }
  return result;
}

// --- Provider Board Certifications Functions ---

/**
 * Creates a new provider board certification record.
 * @param {string} providerId The ID of the provider the board certification belongs to.
 * @param {object} boardCertificationData The data for the new board certification (type, specialty, initialCertificationDate, expirationDate).
 * @returns {object} A success or error message.
 */
function createBoardCertificationInfo(providerId, boardCertificationData) {
  if (!providerId || !boardCertificationData || !boardCertificationData.type || !boardCertificationData.specialty) {
    return { success: false, message: "Provider ID, type, and specialty are required." };
  }
  const rowData = [
      boardCertificationData.type,
      boardCertificationData.specialty,
      boardCertificationData.initialCertificationDate || "",
      boardCertificationData.expirationDate || ""
  ];
  return createSubEntity(
    PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME,
    PROVIDER_BOARD_CERTIFICATIONS_HEADERS,
    providerId,
    rowData,
    `Board Certification "${boardCertificationData.type}"`
  );
}

/**
 * Retrieves a list of board certification records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve board certification records for.
 * @returns {object} An object containing success status and board certification data.
 */
function listBoardCertificationsInfo(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list board certifications." };
    }
    const sheet = getSheet(PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME, PROVIDER_BOARD_CERTIFICATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerBoardCertifications = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerBoardCertifications };
  } catch (error) {
    return { success: false, message: `Failed to list provider board certifications: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider board certification record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the board certification belongs to.
 * @param {string} boardCertificationId The ID of the board certification record to retrieve.
 * @returns {object} An object containing success status and board certification data.
 */
function getBoardCertificationInfo(providerId, boardCertificationId) {
  try {
    if (!providerId || !boardCertificationId) {
      return { success: false, message: "Provider ID and Board Certification ID are required to get board certification details." };
    }
    const sheet = getSheet(PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME, PROVIDER_BOARD_CERTIFICATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const boardCertification = allRecords.find(record => record.providerId === providerId && record.id === boardCertificationId);
    if (!boardCertification) {
      return { success: false, message: `Board Certification with ID ${boardCertificationId} not found for provider ${providerId}.` };
    }
    return { success: true, data: boardCertification };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider board certification details: ${error.message}` };
  }
}

/**
 * Updates an existing provider board certification record.
 * @param {string} boardCertificationId The ID of the board certification record to update.
 * @param {object} boardCertificationData The data to patch (e.g., type, specialty, initialCertificationDate, expirationDate).
 * @returns {object} A success or error message.
 */
function patchBoardCertificationInfo(boardCertificationId, boardCertificationData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME, boardCertificationId, boardCertificationData);
  if (result.success) {
    logAuditEvent("Request", `Provider board certification updated: ${boardCertificationId}`, { boardCertificationId: boardCertificationId, newData: boardCertificationData });
  } else {
    logAuditEvent("Error", `Failed to update provider board certification ${boardCertificationId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider board certification record.
 * @param {string} boardCertificationId The ID of the board certification record to delete.
 * @returns {object} A success or error message.
 */
function deleteBoardCertificationInfo(boardCertificationId) {
  const result = deleteDetailedProviderInfo(PROVIDER_BOARD_CERTIFICATIONS_SHEET_NAME, PROVIDER_BOARD_CERTIFICATIONS_HEADERS, boardCertificationId);
  if (result.success) {
    logAuditEvent("Request", `Provider board certification deleted: ${boardCertificationId}`, { boardCertificationId: boardCertificationId });
  }
  return result;
}

// --- Provider Certificates Functions ---

/**
 * Creates a new provider certificate record.
 * @param {string} providerId The ID of the provider the certificate belongs to.
 * @param {object} certificateData The data for the new certificate (type, certificateNumber, firstName, lastName, issueDate, expirationDate, certifyingOrganization).
 * @returns {object} A success or error message.
 */
function createCertificateInfo(providerId, certificateData) {
  if (!providerId || !certificateData || !certificateData.type || !certificateData.certificateNumber) {
    return { success: false, message: "Provider ID, type, and certificate number are required." };
  }
  const rowData = [
      certificateData.type,
      certificateData.certificateNumber,
      certificateData.firstName || "",
      certificateData.lastName || "",
      certificateData.issueDate || "",
      certificateData.expirationDate || "",
      certificateData.certifyingOrganization || ""
  ];
  return createSubEntity(
    PROVIDER_CERTIFICATES_SHEET_NAME,
    PROVIDER_CERTIFICATES_HEADERS,
    providerId,
    rowData,
    `Certificate "${certificateData.type}"`
  );
}

/**
 * Retrieves a list of certificate records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve certificate records for.
 * @returns {object} An object containing success status and certificate data.
 */
function listCertificateInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list certificates." };
    }
    const sheet = getSheet(PROVIDER_CERTIFICATES_SHEET_NAME, PROVIDER_CERTIFICATES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerCertificates = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerCertificates };
  } catch (error) {
    return { success: false, message: `Failed to list provider certificates: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider certificate record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the certificate belongs to.
 * @param {string} certificateId The ID of the certificate record to retrieve.
 * @returns {object} An object containing success status and certificate data.
 */
function getCertificateInfo(providerId, certificateId) {
  try {
    if (!providerId || !certificateId) {
      return { success: false, message: "Provider ID and Certificate ID are required to get certificate details." };
    }
    const sheet = getSheet(PROVIDER_CERTIFICATES_SHEET_NAME, PROVIDER_CERTIFICATES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const certificate = allRecords.find(record => record.providerId === providerId && record.id === certificateId);
    if (!certificate) {
      return { success: false, message: `Certificate with ID ${certificateId} not found for provider ${providerId}.` };
    }
    return { success: true, data: certificate };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider certificate details: ${error.message}` };
  }
}

/**
 * Updates an existing provider certificate record.
 * @param {string} certificateId The ID of the certificate record to update.
 * @param {object} certificateData The data to patch (e.g., type, certificateNumber, firstName, lastName, issueDate, expirationDate, certifyingOrganization).
 * @returns {object} A success or error message.
 */
function patchCertificateInfo(certificateId, certificateData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_CERTIFICATES_SHEET_NAME, certificateId, certificateData);
  if (result.success) {
    logAuditEvent("Request", `Provider certificate updated: ${certificateId}`, { certificateId: certificateId, newData: certificateData });
  } else {
    logAuditEvent("Error", `Failed to update provider certificate ${certificateId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider certificate record.
 * @param {string} certificateId The ID of the certificate record to delete.
 * @returns {object} A success or error message.
 */
function deleteCertificateInfo(certificateId) {
  const result = deleteDetailedProviderInfo(PROVIDER_CERTIFICATES_SHEET_NAME, PROVIDER_CERTIFICATES_HEADERS, certificateId);
  if (result.success) {
    logAuditEvent("Request", `Provider certificate deleted: ${certificateId}`, { certificateId: certificateId });
  }
  return result;
}

// --- Provider CAQH Info Functions ---

/**
 * Creates or updates a provider's CAQH login information.
 * This function acts as a 'put' operation: it will create if not exists, or replace if it does.
 * For simplicity, we'll implement it as a create or update based on existence.
 * @param {string} providerId The ID of the provider the CAQH info belongs to.
 * @param {object} caqhData The CAQH data (caqhId).
 * @returns {object} A success or error message.
 */
function putProviderCaqhInfo(providerId, caqhData) {
  try {
    if (!providerId || !caqhData || !caqhData.caqhId) {
      return { success: false, message: "Provider ID and CAQH ID are required for CAQH info." };
    }
    const sheet = getSheet(PROVIDER_CAQH_INFO_SHEET_NAME, PROVIDER_CAQH_INFO_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const existingRecord = allRecords.find(record => record.providerId === providerId);

    if (existingRecord) {
      // Update existing record
      const result = patchDetailedInfo(PROVIDER_CAQH_INFO_SHEET_NAME, existingRecord.id, { caqhId: caqhData.caqhId, lastUpdatedAt: new Date().toISOString() });
      if (result.success) {
        logAuditEvent("Request", `Provider CAQH info updated for provider ${providerId}`, { providerId: providerId, caqhId: caqhData.caqhId });
        return { success: true, message: `CAQH info updated for provider ${providerId}.` };
      } else {
        return { success: false, message: `Failed to update CAQH info: ${result.message}` };
      }
    } else {
      // Create new record
      const newId = Utilities.getUuid();
      // Headers: ["ID", "Provider ID", "CAQH ID", "Last Updated At"]
      const rowData = [newId, providerId, caqhData.caqhId, new Date().toISOString()];
      sheet.appendRow(rowData);
      invalidateRowIndexCache(sheet);
      logAuditEvent("Request", `Provider CAQH info created for provider ${providerId}`, { providerId: providerId, caqhId: caqhData.caqhId });
      return { success: true, message: `CAQH info created for provider ${providerId}.` };
    }
  } catch (error) {
    return { success: false, message: `Failed to put provider CAQH info: ${error.message}` };
  }
}

/**
 * Patches an existing provider's CAQH login information.
 * This function assumes the record already exists and only updates specified fields.
 * @param {string} providerId The ID of the provider the CAQH info belongs to.
 * @param {object} caqhData The CAQH data to patch (caqhId).
 * @returns {object} A success or error message.
 */
function patchProviderCaqhInfo(providerId, caqhData) {
  try {
    if (!providerId || !caqhData || !caqhData.caqhId) {
      return { success: false, message: "Provider ID and CAQH ID are required for patching CAQH info." };
    }
    const sheet = getSheet(PROVIDER_CAQH_INFO_SHEET_NAME, PROVIDER_CAQH_INFO_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const existingRecord = allRecords.find(record => record.providerId === providerId);

    if (!existingRecord) {
      return { success: false, message: `CAQH info not found for provider ${providerId}. Use putProviderCaqhInfo to create.` };
    }

    const result = patchDetailedInfo(PROVIDER_CAQH_INFO_SHEET_NAME, existingRecord.id, { caqhId: caqhData.caqhId, lastUpdatedAt: new Date().toISOString() });
    if (result.success) {
      logAuditEvent("Request", `Provider CAQH info patched for provider ${providerId}`, { providerId: providerId, caqhId: caqhData.caqhId });
      return { success: true, message: `CAQH info patched for provider ${providerId}.` };
    } else {
      return { success: false, message: `Failed to patch CAQH info: ${result.message}` };
    }
  } catch (error) {
    return { success: false, message: `Failed to patch provider CAQH info: ${error.message}` };
  }
}

/**
 * Deletes a provider's CAQH login information.
 * @param {string} providerId The ID of the provider whose CAQH info to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderCaqhInfo(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to delete CAQH info." };
    }
    const sheet = getSheet(PROVIDER_CAQH_INFO_SHEET_NAME, PROVIDER_CAQH_INFO_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const existingRecord = allRecords.find(record => record.providerId === providerId);

    if (!existingRecord) {
      return { success: false, message: `CAQH info not found for provider ${providerId}.` };
    }

    const result = deleteDetailedProviderInfo(PROVIDER_CAQH_INFO_SHEET_NAME, PROVIDER_CAQH_INFO_HEADERS, existingRecord.id);
    if (result.success) {
      logAuditEvent("Request", `Provider CAQH info deleted for provider ${providerId}`, { providerId: providerId });
      return { success: true, message: `CAQH info deleted for provider ${providerId}.` };
    } else {
      return { success: false, message: `Failed to delete CAQH info: ${result.message}` };
    }
  } catch (error) {
    return { success: false, message: `Failed to delete provider CAQH info: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider's CAQH login information.
 * @param {string} providerId The ID of the provider to retrieve CAQH info for.
 * @returns {object} An object containing success status and CAQH data.
 */
function getProviderCaqhInfo(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to get CAQH info." };
    }
    const sheet = getSheet(PROVIDER_CAQH_INFO_SHEET_NAME, PROVIDER_CAQH_INFO_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const caqhInfo = allRecords.find(record => record.providerId === providerId);
    if (!caqhInfo) {
      return { success: false, message: `CAQH info not found for provider ${providerId}.` };
    }
    return { success: true, data: caqhInfo };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider CAQH info: ${error.message}` };
  }
}

// --- Provider Liability Insurance Functions ---

/**
 * Creates a new provider liability insurance record.
 * @param {string} providerId The ID of the provider the liability insurance belongs to.
 * @param {object} liabilityInsuranceData The data for the new liability insurance record.
 * @returns {object} A success or error message.
 */
function createProviderLiabilityInsurance(providerId, liabilityInsuranceData) {
  if (!providerId || !liabilityInsuranceData || !liabilityInsuranceData.name) {
    return { success: false, message: "Provider ID and insurer name are required." };
  }
  const rowData = [
      liabilityInsuranceData.name,
      liabilityInsuranceData.isSelfInsured || false,
      liabilityInsuranceData.originalEffectiveDate || "",
      liabilityInsuranceData.currentEffectiveDate || "",
      liabilityInsuranceData.currentExpirationDate || "",
      liabilityInsuranceData.coverageType || "",
      liabilityInsuranceData.isUnlimitedCoverage || false,
      liabilityInsuranceData.includesTailCoverage || false,
      liabilityInsuranceData.occurrenceCoverageAmount || "",
      liabilityInsuranceData.aggregateCoverageAmount || "",
      liabilityInsuranceData.policyNumber || ""
  ];
  return createSubEntity(
    PROVIDER_LIABILITY_INSURANCE_SHEET_NAME,
    PROVIDER_LIABILITY_INSURANCE_HEADERS,
    providerId,
    rowData,
    `Liability Insurance "${liabilityInsuranceData.name}"`
  );
}

/**
 * Retrieves a list of liability insurance records for a given provider.
 * @param {string} providerId The ID of the provider to retrieve liability insurance records for.
 * @returns {object} An object containing success status and liability insurance data.
 */
function listProviderLiabilityInsuranceInfos(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to list liability insurance records." };
    }
    const sheet = getSheet(PROVIDER_LIABILITY_INSURANCE_SHEET_NAME, PROVIDER_LIABILITY_INSURANCE_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const providerLiabilityInsurances = allRecords.filter(record => record.providerId === providerId);
    return { success: true, data: providerLiabilityInsurances };
  } catch (error) {
    return { success: false, message: `Failed to list provider liability insurance records: ${error.message}` };
  }
}

/**
 * Retrieves a specific provider liability insurance record by its ID and provider ID.
 * @param {string} providerId The ID of the provider the liability insurance belongs to.
 * @param {string} liabilityInsuranceId The ID of the liability insurance record to retrieve.
 * @returns {object} An object containing success status and liability insurance data.
 */
function getProviderLiabilityInsuranceInfo(providerId, liabilityInsuranceId) {
  try {
    if (!providerId || !liabilityInsuranceId) {
      return { success: false, message: "Provider ID and Liability Insurance ID are required to get liability insurance details." };
    }
    const sheet = getSheet(PROVIDER_LIABILITY_INSURANCE_SHEET_NAME, PROVIDER_LIABILITY_INSURANCE_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const liabilityInsurance = allRecords.find(record => record.providerId === providerId && record.id === liabilityInsuranceId);
    if (!liabilityInsurance) {
      return { success: false, message: `Liability Insurance with ID ${liabilityInsuranceId} not found for provider ${providerId}.` };
    }
    return { success: true, data: liabilityInsurance };
  } catch (error) {
    return { success: false, message: `Failed to retrieve provider liability insurance details: ${error.message}` };
  }
}

/**
 * Updates an existing provider liability insurance record.
 * @param {string} liabilityInsuranceId The ID of the liability insurance record to update.
 * @param {object} liabilityInsuranceData The data to patch.
 * @returns {object} A success or error message.
 */
function patchProviderLiabilityInsuranceInfo(liabilityInsuranceId, liabilityInsuranceData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(PROVIDER_LIABILITY_INSURANCE_SHEET_NAME, liabilityInsuranceId, liabilityInsuranceData);
  if (result.success) {
    logAuditEvent("Request", `Provider liability insurance updated: ${liabilityInsuranceId}`, { liabilityInsuranceId: liabilityInsuranceId, newData: liabilityInsuranceData });
  } else {
    logAuditEvent("Error", `Failed to update provider liability insurance ${liabilityInsuranceId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a provider liability insurance record.
 * @param {string} liabilityInsuranceId The ID of the liability insurance record to delete.
 * @returns {object} A success or error message.
 */
function deleteProviderLiabilityInsuranceInfo(liabilityInsuranceId) {
  const result = deleteDetailedProviderInfo(PROVIDER_LIABILITY_INSURANCE_SHEET_NAME, PROVIDER_LIABILITY_INSURANCE_HEADERS, liabilityInsuranceId);
  if (result.success) {
    logAuditEvent("Request", `Provider liability insurance deleted: ${liabilityInsuranceId}`, { liabilityInsuranceId: liabilityInsuranceId });
  }
  return result;
}

// --- Provider Profiles Functions ---

/**
 * Lists available provider profile import sources.
 * @returns {object} An object containing success status and a list of import sources.
 */
function listProviderProfileImportSources() {
  try {
    const sheet = getSheet(PROVIDER_PROFILE_IMPORT_SOURCES_SHEET_NAME, PROVIDER_PROFILE_IMPORT_SOURCES_HEADERS);
    const sources = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: sources };
  } catch (error) {
    logAuditEvent("Error", `Failed to list provider profile import sources: ${error.message}`);
    return { success: false, message: `Failed to list provider profile import sources: ${error.message}` };
  }
}

/**
 * Creates a new provider profile import job.
 * @param {object} importData The data for the new import (providerId, source, parameters).
 * @returns {object} A success or error message, with the new import data on success.
 */
function createProviderProfileImport(importData) {
  try {
    if (!importData.providerId || !importData.source) {
      return { success: false, message: "Provider ID and source are required for profile import." };
    }

    const sheet = getSheet(PROVIDER_PROFILE_IMPORTS_SHEET_NAME, PROVIDER_PROFILE_IMPORTS_HEADERS);
    const newId = Utilities.getUuid();
    const now = new Date().toISOString();

    // Simulate immediate completion for simplicity, or "Working" then a separate function to "Complete"
    const status = "Completed";
    const completedAt = now;

    const rowData = [
      newId,
      importData.providerId,
      importData.source,
      status,
      now,
      completedAt,
      "", // Failure Code
      "", // Failure Reason
      JSON.stringify(importData.profileData || {}) // Mock profile data
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    logAuditEvent("Request", `Provider profile import created: ${newId} for provider ${importData.providerId} from ${importData.source}`, { providerId: importData.providerId, importId: newId, source: importData.source });
    return { success: true, message: `Profile import created with ID: ${newId}`, data: { id: newId, status: status } };
  } catch (error) {
    logAuditEvent("Error", `Failed to create provider profile import: ${error.message}`);
    return { success: false, message: `Failed to create provider profile import: ${error.message}` };
  }
}

/**
 * Retrieves details for a specific provider profile import job.
 * @param {string} importId The ID of the import job to retrieve.
 * @returns {object} An object containing success status and the import job data.
 */
function getProviderProfileImport(importId) {
  try {
    if (!importId) {
      return { success: false, message: "Import ID is required." };
    }
    const sheet = getSheet(PROVIDER_PROFILE_IMPORTS_SHEET_NAME, PROVIDER_PROFILE_IMPORTS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const importJob = allRecords.find(record => record.id === importId);
    if (!importJob) {
      return { success: false, message: `Provider profile import with ID ${importId} not found.` };
    }
    return { success: true, data: importJob };
  } catch (error) {
    logAuditEvent("Error", `Failed to get provider profile import ${importId}: ${error.message}`);
    return { success: false, message: `Failed to get provider profile import: ${error.message}` };
  }
}

/**
 * Lists provider profile import jobs with filtering and pagination.
 * @param {object} options - An object with pagination, sorting, and filtering parameters.
 * @param {number} [options.page=1] - The page number to retrieve.
 * @param {number} [options.pageSize=15] - The number of records per page.
 * @param {string} [options.providerId] - Filter by provider ID.
 * @param {string} [options.source] - Filter by import source.
 * @param {string} [options.status] - Filter by import status.
 * @returns {object} An object with the list of import jobs and pagination info.
 */
function listProviderProfileImports(options = {}) {
  try {
    const { page = 1, pageSize = 15, providerId, source, status } = options;
    const sheet = getSheet(PROVIDER_PROFILE_IMPORTS_SHEET_NAME, PROVIDER_PROFILE_IMPORTS_HEADERS);
    let allImports = sheetDataToObjects(sheet.getDataRange().getValues());

    if (providerId) {
      allImports = allImports.filter(job => job.providerId === providerId);
    }
    if (source) {
      allImports = allImports.filter(job => job.source === source);
    }
    if (status) {
      allImports = allImports.filter(job => job.status === status);
    }

    // Sort by 'Started' date, newest first
    allImports.sort((a, b) => new Date(b.started) - new Date(a.started));

    const totalRecords = allImports.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allImports.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list provider profile imports: ${error.message}`);
    return { success: false, message: `Failed to list provider profile imports: ${error.message}` };
  }
}


// --- Facility DEA Functions ---

/**
 * Creates a new facility DEA record.
 * @param {string} facilityId The ID of the facility the DEA belongs to.
 * @param {object} deaData The data for the new DEA record (deaNumber, drugSchedules, state, expirationDate, businessActivityCode, paymentIndicator, isActive).
 * @returns {object} A success or error message.
 */
function createFacilityDeaInfo(facilityId, deaData) {
  if (!facilityId || !deaData || !deaData.deaNumber) {
    return { success: false, message: "Facility ID and DEA number are required." };
  }
  const rowData = [
      deaData.deaNumber,
      deaData.drugSchedules || "",
      deaData.state || "",
      deaData.expirationDate || "",
      deaData.businessActivityCode || "",
      deaData.paymentIndicator || "",
      deaData.isActive || false
  ];
  return createSubEntity(
    FACILITY_DEAS_SHEET_NAME,
    FACILITY_DEAS_HEADERS,
    facilityId,
    rowData,
    `Facility DEA "${deaData.deaNumber}"`
  );
}

/**
 * Retrieves a list of DEA records for a given facility.
 * @param {string} facilityId The ID of the facility to retrieve DEA records for.
 * @returns {object} An object containing success status and DEA data.
 */
function listFacilityDeaInfo(facilityId) {
  try {
    if (!facilityId) {
      return { success: false, message: "Facility ID is required to list DEAs." };
    }
    const sheet = getSheet(FACILITY_DEAS_SHEET_NAME, FACILITY_DEAS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const facilityDeas = allRecords.filter(record => record.facilityId === facilityId);
    return { success: true, data: facilityDeas };
  } catch (error) {
    return { success: false, message: `Failed to list facility DEAs: ${error.message}` };
  }
}

/**
 * Retrieves a specific facility DEA record by its ID and facility ID.
 * @param {string} facilityId The ID of the facility the DEA belongs to.
 * @param {string} deaId The ID of the DEA record to retrieve.
 * @returns {object} An object containing success status and DEA data.
 */
function getFacilityDeaInfo(facilityId, deaId) {
  try {
    if (!facilityId || !deaId) {
      return { success: false, message: "Facility ID and DEA ID are required to get DEA details." };
    }
    const sheet = getSheet(FACILITY_DEAS_SHEET_NAME, FACILITY_DEAS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const dea = allRecords.find(record => record.facilityId === facilityId && record.id === deaId);
    if (!dea) {
      return { success: false, message: `DEA with ID ${deaId} not found for facility ${facilityId}.` };
    }
    return { success: true, data: dea };
  } catch (error) {
    return { success: false, message: `Failed to retrieve facility DEA details: ${error.message}` };
  }
}

/**
 * Updates an existing facility DEA record.
 * @param {string} deaId The ID of the DEA record to update.
 * @param {object} deaData The data to patch.
 * @returns {object} A success or error message.
 */
function patchFacilityDeaInfo(deaId, deaData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(FACILITY_DEAS_SHEET_NAME, deaId, deaData);
  if (result.success) {
    logAuditEvent("Request", `Facility DEA updated: ${deaId}`, { deaId: deaId, newData: deaData });
  } else {
    logAuditEvent("Error", `Failed to update facility DEA ${deaId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a facility DEA record.
 * @param {string} deaId The ID of the DEA record to delete.
 * @returns {object} A success or error message.
 */
function deleteFacilityDeaInfo(deaId) {
  const result = deleteDetailedProviderInfo(FACILITY_DEAS_SHEET_NAME, FACILITY_DEAS_HEADERS, deaId);
  if (result.success) {
    logAuditEvent("Request", `Facility DEA deleted: ${deaId}`, { deaId: deaId });
  }
  return result;
}

// --- Facility Liability Insurance Functions ---

/**
 * Creates a new facility liability insurance record.
 * @param {string} facilityId The ID of the facility the liability insurance belongs to.
 * @param {object} liabilityInsuranceData The data for the new liability insurance record.
 * @returns {object} A success or error message.
 */
function createFacilityLiabilityInsuranceInfo(facilityId, liabilityInsuranceData) {
  if (!facilityId || !liabilityInsuranceData || !liabilityInsuranceData.name) {
    return { success: false, message: "Facility ID and insurer name are required." };
  }
  const rowData = [
      liabilityInsuranceData.name,
      liabilityInsuranceData.isSelfInsured || false,
      liabilityInsuranceData.originalEffectiveDate || "",
      liabilityInsuranceData.currentEffectiveDate || "",
      liabilityInsuranceData.currentExpirationDate || "",
      liabilityInsuranceData.coverageType || "",
      liabilityInsuranceData.isUnlimitedCoverage || false,
      liabilityInsuranceData.includesTailCoverage || false,
      liabilityInsuranceData.occurrenceCoverageAmount || "",
      liabilityInsuranceData.aggregateCoverageAmount || "",
      liabilityInsuranceData.policyNumber || ""
  ];
  return createSubEntity(
    FACILITY_LIABILITY_INSURANCE_SHEET_NAME,
    FACILITY_LIABILITY_INSURANCE_HEADERS,
    facilityId,
    rowData,
    `Facility Liability Insurance "${liabilityInsuranceData.name}"`
  );
}

/**
 * Retrieves a list of liability insurance records for a given facility.
 * @param {string} facilityId The ID of the facility to retrieve liability insurance records for.
 * @returns {object} An object containing success status and liability insurance data.
 */
function listFacilityLiabilityInsuranceInfo(facilityId) {
  try {
    if (!facilityId) {
      return { success: false, message: "Facility ID is required to list liability insurance records." };
    }
    const sheet = getSheet(FACILITY_LIABILITY_INSURANCE_SHEET_NAME, FACILITY_LIABILITY_INSURANCE_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const facilityLiabilityInsurances = allRecords.filter(record => record.facilityId === facilityId);
    return { success: true, data: facilityLiabilityInsurances };
  } catch (error) {
    return { success: false, message: `Failed to list facility liability insurance records: ${error.message}` };
  }
}

/**
 * Retrieves a specific facility liability insurance record by its ID and facility ID.
 * @param {string} facilityId The ID of the facility the liability insurance belongs to.
 * @param {string} liabilityInsuranceId The ID of the liability insurance record to retrieve.
 * @returns {object} An object containing success status and liability insurance data.
 */
function getFacilityLiabilityInsuranceInfo(facilityId, liabilityInsuranceId) {
  try {
    if (!facilityId || !liabilityInsuranceId) {
      return { success: false, message: "Facility ID and Liability Insurance ID are required to get liability insurance details." };
    }
    const sheet = getSheet(FACILITY_LIABILITY_INSURANCE_SHEET_NAME, FACILITY_LIABILITY_INSURANCE_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const liabilityInsurance = allRecords.find(record => record.facilityId === facilityId && record.id === liabilityInsuranceId);
    if (!liabilityInsurance) {
      return { success: false, message: `Liability Insurance with ID ${liabilityInsuranceId} not found for facility ${facilityId}.` };
    }
    return { success: true, data: liabilityInsurance };
  } catch (error) {
    return { success: false, message: `Failed to retrieve facility liability insurance details: ${error.message}` };
  }
}

/**
 * Updates an existing facility liability insurance record.
 * @param {string} liabilityInsuranceId The ID of the liability insurance record to update.
 * @param {object} liabilityInsuranceData The data to patch.
 * @returns {object} A success or error message.
 */
function patchFacilityLiabilityInsuranceInfo(liabilityInsuranceId, liabilityInsuranceData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(FACILITY_LIABILITY_INSURANCE_SHEET_NAME, liabilityInsuranceId, liabilityInsuranceData);
  if (result.success) {
    logAuditEvent("Request", `Facility liability insurance updated: ${liabilityInsuranceId}`, { liabilityInsuranceId: liabilityInsuranceId, newData: liabilityInsuranceData });
  } else {
    logAuditEvent("Error", `Failed to update facility liability insurance ${liabilityInsuranceId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a facility liability insurance record.
 * @param {string} liabilityInsuranceId The ID of the liability insurance record to delete.
 * @returns {object} A success or error message.
 */
function deleteFacilityLiabilityInsuranceInfo(liabilityInsuranceId) {
  const result = deleteDetailedProviderInfo(FACILITY_LIABILITY_INSURANCE_SHEET_NAME, FACILITY_LIABILITY_INSURANCE_HEADERS, liabilityInsuranceId);
  if (result.success) {
    logAuditEvent("Request", `Facility liability insurance deleted: ${liabilityInsuranceId}`, { liabilityInsuranceId: liabilityInsuranceId });
  }
  return result;
}

// --- Facility Licenses Functions ---

/**
 * Creates a new facility license record.
 * @param {string} facilityId The ID of the facility the license belongs to.
 * @param {object} licenseData The data for the new license record (licenseTypeID, state, licenseNumber, isPrimary, issueDate, expirationDate, licenseStatus).
 * @returns {object} A success or error message.
 */
function createFacilityLicenseInfo(facilityId, licenseData) {
  if (!facilityId || !licenseData || !licenseData.licenseTypeID || !licenseData.state || !licenseData.licenseNumber) {
    return { success: false, message: "Facility ID, license type ID, state, and license number are required." };
  }
  const rowData = [
      licenseData.licenseTypeID,
      licenseData.state,
      licenseData.licenseNumber,
      licenseData.isPrimary || false,
      licenseData.issueDate || "",
      licenseData.expirationDate || "",
      licenseData.licenseStatus || ""
  ];
  return createSubEntity(
    FACILITY_LICENSES_SHEET_NAME,
    FACILITY_LICENSES_HEADERS,
    facilityId,
    rowData,
    `Facility License "${licenseData.licenseNumber}"`
  );
}

/**
 * Retrieves a list of license records for a given facility.
 * @param {string} facilityId The ID of the facility to retrieve license records for.
 * @returns {object} An object containing success status and license data.
 */
function listFacilityLicenseInfo(facilityId) {
  try {
    if (!facilityId) {
      return { success: false, message: "Facility ID is required to list licenses." };
    }
    const sheet = getSheet(FACILITY_LICENSES_SHEET_NAME, FACILITY_LICENSES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const facilityLicenses = allRecords.filter(record => record.facilityId === facilityId);
    return { success: true, data: facilityLicenses };
  } catch (error) {
    return { success: false, message: `Failed to list facility licenses: ${error.message}` };
  }
}

/**
 * Retrieves a specific facility license record by its ID and facility ID.
 * @param {string} facilityId The ID of the facility the license belongs to.
 * @param {string} licenseId The ID of the license record to retrieve.
 * @returns {object} An object containing success status and license data.
 */
function getFacilityLicenseInfo(facilityId, licenseId) {
  try {
    if (!facilityId || !licenseId) {
      return { success: false, message: "Facility ID and License ID are required to get license details." };
    }
    const sheet = getSheet(FACILITY_LICENSES_SHEET_NAME, FACILITY_LICENSES_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const license = allRecords.find(record => record.facilityId === facilityId && record.id === licenseId);
    if (!license) {
      return { success: false, message: `License with ID ${licenseId} not found for facility ${facilityId}.` };
    }
    return { success: true, data: license };
  } catch (error) {
    return { success: false, message: `Failed to retrieve facility license details: ${error.message}` };
  }
}

/**
 * Updates an existing facility license record.
 * @param {string} licenseId The ID of the license record to update.
 * @param {object} licenseData The data to patch.
 * @returns {object} A success or error message.
 */
function patchFacilityLicenseInfo(licenseId, licenseData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(FACILITY_LICENSES_SHEET_NAME, licenseId, licenseData);
  if (result.success) {
    logAuditEvent("Request", `Facility license updated: ${licenseId}`, { licenseId: licenseId, newData: licenseData });
  } else {
    logAuditEvent("Error", `Failed to update facility license ${licenseId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a facility license record.
 * @param {string} licenseId The ID of the license record to delete.
 * @returns {object} A success or error message.
 */
function deleteFacilityLicenseInfo(licenseId) {
  const result = deleteDetailedProviderInfo(FACILITY_LICENSES_SHEET_NAME, FACILITY_LICENSES_HEADERS, licenseId);
  if (result.success) {
    logAuditEvent("Request", `Facility license deleted: ${licenseId}`, { licenseId: licenseId });
  }
  return result;
}

// --- Facility Accreditations Functions ---

/**
 * Creates a new facility accreditation record.
 * @param {string} facilityId The ID of the facility the accreditation belongs to.
 * @param {object} accreditationData The data for the new accreditation record (agency, program, decision, effectiveDate, expirationDate).
 * @returns {object} A success or error message.
 */
function createFacilityAccreditationInfo(facilityId, accreditationData) {
  if (!facilityId || !accreditationData || !accreditationData.agency || !accreditationData.program) {
    return { success: false, message: "Facility ID, agency, and program are required." };
  }
  const rowData = [
      accreditationData.agency,
      accreditationData.program,
      accreditationData.decision || "",
      accreditationData.effectiveDate || "",
      accreditationData.expirationDate || ""
  ];
  return createSubEntity(
    FACILITY_ACCREDITATIONS_SHEET_NAME,
    FACILITY_ACCREDITATIONS_HEADERS,
    facilityId,
    rowData,
    `Facility Accreditation "${accreditationData.agency}"`
  );
}

/**
 * Retrieves a list of accreditation records for a given facility.
 * @param {string} facilityId The ID of the facility to retrieve accreditation records for.
 * @returns {object} An object containing success status and accreditation data.
 */
function listFacilityAccreditationInfo(facilityId) {
  try {
    if (!facilityId) {
      return { success: false, message: "Facility ID is required to list accreditations." };
    }
    const sheet = getSheet(FACILITY_ACCREDITATIONS_SHEET_NAME, FACILITY_ACCREDITATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const facilityAccreditations = allRecords.filter(record => record.facilityId === facilityId);
    return { success: true, data: facilityAccreditations };
  } catch (error) {
    return { success: false, message: `Failed to list facility accreditations: ${error.message}` };
  }
}

/**
 * Retrieves a specific facility accreditation record by its ID and facility ID.
 * @param {string} facilityId The ID of the facility the accreditation belongs to.
 * @param {string} accreditationId The ID of the accreditation record to retrieve.
 * @returns {object} An object containing success status and accreditation data.
 */
function getFacilityAccreditationInfo(facilityId, accreditationId) {
  try {
    if (!facilityId || !accreditationId) {
      return { success: false, message: "Facility ID and Accreditation ID are required to get accreditation details." };
    }
    const sheet = getSheet(FACILITY_ACCREDITATIONS_SHEET_NAME, FACILITY_ACCREDITATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const accreditation = allRecords.find(record => record.facilityId === facilityId && record.id === accreditationId);
    if (!accreditation) {
      return { success: false, message: `Accreditation with ID ${accreditationId} not found for facility ${facilityId}.` };
    }
    return { success: true, data: accreditation };
  } catch (error) {
    return { success: false, message: `Failed to retrieve facility accreditation details: ${error.message}` };
  }
}

/**
 * Updates an existing facility accreditation record.
 * @param {string} accreditationId The ID of the accreditation record to update.
 * @param {object} accreditationData The data to patch.
 * @returns {object} A success or error message.
 */
function patchFacilityAccreditationInfo(accreditationId, accreditationData) {
  // Using patchDetailedInfo for a generic update.
  const result = patchDetailedInfo(FACILITY_ACCREDITATIONS_SHEET_NAME, accreditationId, accreditationData);
  if (result.success) {
    logAuditEvent("Request", `Facility accreditation updated: ${accreditationId}`, { accreditationId: accreditationId, newData: accreditationData });
  } else {
    logAuditEvent("Error", `Failed to update facility accreditation ${accreditationId}: ${result.message}`);
  }
  return result;
}

/**
 * Deletes a facility accreditation record.
 * @param {string} accreditationId The ID of the accreditation record to delete.
 * @returns {object} A success or error message.
 */
function deleteFacilityAccreditationInfo(accreditationId) {
  const result = deleteDetailedProviderInfo(FACILITY_ACCREDITATIONS_SHEET_NAME, FACILITY_ACCREDITATIONS_HEADERS, accreditationId);
  if (result.success) {
    logAuditEvent("Request", `Facility accreditation deleted: ${accreditationId}`, { accreditationId: accreditationId });
  }
  return result;
}

/**
 * Get provider aggregations
 * @param {object} [query={}] Query parameters (providerDeactivated)
 * @returns {Promise<Models.ProviderAggregationsModel>}
 */
function getProviderAggregations(query = {}) {
  try {
    const sheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    let allProviders = sheetDataToObjects(sheet.getDataRange().getValues());

    if (query && query.providerDeactivated === false) {
      allProviders = allProviders.filter(p => !p.deactivated);
    }

    const total = allProviders.length;
    const aggregations = allProviders.reduce((acc, provider) => {
      const status = provider.credentialingStatus || 'Unknown';
      acc[status] = (acc[status] || 0) + 1;
      return acc;
    }, {});

    return { success: true, data: { total, aggregations } };
  } catch (error) {
    logAuditEvent("Error", `Failed to get provider aggregations: ${error.message}`);
    return { success: false, message: `Failed to get provider aggregations: ${error.message}` };
  }
}

/**
 * List providers due for recredentialing
 * @param {object} [query={}] Query parameters (nextCredentialingDateOnOrBefore, sortedBy, sortOrder, page, pageSize)
 * @returns {Promise<Models.ProviderDueForRecredentialingPageModel>}
 */
function listProvidersDueForRecredentialing(query = {}) {
  try {
    const { 
      page = 1, 
      pageSize = 25, 
      sortedBy = 'nextCredentialingDate', 
      sortOrder = 'asc',
      nextCredentialingDateOnOrBefore 
    } = query;

    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());

    const requestsSheet = getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS);
    const allRequests = sheetDataToObjects(requestsSheet.getDataRange().getValues());
    const requestMap = new Map(allRequests.map(r => [r.providerId, r]));

    const cutOffDate = nextCredentialingDateOnOrBefore ? new Date(nextCredentialingDateOnOrBefore) : new Date(new Date().setDate(new Date().getDate() + 90));

    let providersDue = allProviders.filter(p => {
      if (p.deactivated || !p.nextCredentialingDate) return false;
      const dueDate = new Date(p.nextCredentialingDate);
      return dueDate <= cutOffDate;
    });

    let enrichedProviders = providersDue.map(p => {
      const request = requestMap.get(p.id);
      return {
        ...p, // Spread all provider fields
        requestId: request ? request.id : null,
        requestType: request ? request.type : null,
        requestCreatedAt: request ? request.createdAt : null,
        currentEvent: request ? request.currentEvent : null,
        requestPriority: request ? request.priority : null,
        isSelfManaged: request ? request.isSelfManaged : null,
        currentEventStatus: request && request.currentEvent ? request.currentEvent.status : null,
        currentEventDate: request && request.currentEvent ? request.currentEvent.timestamp : null,
        owner: request ? request.owner : null,
      };
    });

    // Sorting
    enrichedProviders.sort((a, b) => {
      const valA = a[sortedBy] || '';
      const valB = b[sortedBy] || '';
      let comparison = 0;
      if (sortedBy.toLowerCase().includes('date')) {
        comparison = new Date(valA) > new Date(valB) ? 1 : -1;
      } else {
        if (String(valA).toLowerCase() > String(valB).toLowerCase()) {
          comparison = 1;
        } else if (String(valA).toLowerCase() < String(valB).toLowerCase()) {
          comparison = -1;
        }
      }
      return sortOrder === 'desc' ? comparison * -1 : comparison;
    });

    const totalRecords = enrichedProviders.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = enrichedProviders.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list providers due for recredentialing: ${error.message}`);
    return { success: false, message: `Failed to list providers due for recredentialing: ${error.message}` };
  }
}

/**
 * Get provider sanctions and exclusions monitoring categories aggregations
 * @returns {Promise<Models.ProviderMonitoringSanctionsAndExclusionsSummaryAggregationsModel>}
 */
function getProviderMonitoringSanctionsAndExclusionsSummaryAggregations() {
  try {
    const SANCTIONS_DATASETS = new Set(['OigExclusions', 'Sam', 'StateSanctionsAndExclusions']);
    
    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues()).filter(p => !p.deactivated);
    
    const monitorsSheet = getSheet(MONITORS_SHEET_NAME, MONITORS_HEADERS);
    const allMonitors = sheetDataToObjects(monitorsSheet.getDataRange().getValues());

    const providerMonitorMap = new Map();
    allMonitors.forEach(monitor => {
      if (monitor.type === 'Dataset' && SANCTIONS_DATASETS.has(monitor.datasetType)) {
        if (!providerMonitorMap.has(monitor.providerId)) {
          providerMonitorMap.set(monitor.providerId, new Set());
        }
        providerMonitorMap.get(monitor.providerId).add(monitor.datasetType);
      }
    });

    const aggregations = {
      notMonitored: 0,
      partiallyMonitored: 0,
      fullyMonitored: 0
    };

    allProviders.forEach(provider => {
      const monitoredSets = providerMonitorMap.get(provider.id);
      if (!monitoredSets || monitoredSets.size === 0) {
        aggregations.notMonitored++;
      } else if (monitoredSets.size === SANCTIONS_DATASETS.size) {
        aggregations.fullyMonitored++;
      } else {
        aggregations.partiallyMonitored++;
      }
    });

    return { success: true, data: aggregations };
  } catch (error) {
    logAuditEvent("Error", `Failed to get monitoring aggregations: ${error.message}`);
    return { success: false, message: `Failed to get monitoring aggregations: ${error.message}` };
  }
}

// --- Facility CMS Certifications Functions ---

/**
 * Creates a new facility CMS certification record.
 * @param {string} facilityId The ID of the facility the CMS certification belongs to.
 * @param {object} cmsCertificationData The data for the new CMS certification record (certificationNumber, certificationDate).
 * @returns {object} A success or error message.
 */
function createFacilityCmsCertificationInfo(facilityId, cmsCertificationData) {
  if (!facilityId || !cmsCertificationData || !cmsCertificationData.certificationNumber) {
    return { success: false, message: "Facility ID and certification number are required." };
  }
  const rowData = [
      cmsCertificationData.certificationNumber,
      cmsCertificationData.certificationDate || ""
  ];
  return createSubEntity(
    FACILITY_CMS_CERTIFICATIONS_SHEET_NAME,
    FACILITY_CMS_CERTIFICATIONS_HEADERS,
    facilityId,
    rowData,
    `Facility CMS Certification "${cmsCertificationData.certificationNumber}"`
  );
}

/**
 * Retrieves a list of CMS certification records for a given facility.
 * @param {string} facilityId The ID of the facility to retrieve CMS certification records for.
 * @returns {object} An object containing success status and CMS certification data.
 */
function listFacilityCmsCertificationInfo(facilityId) {
  try {
    if (!facilityId) {
      return { success: false, message: "Facility ID is required to list CMS certifications." };
    }
    const sheet = getSheet(FACILITY_CMS_CERTIFICATIONS_SHEET_NAME, FACILITY_CMS_CERTIFICATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const facilityCmsCertifications = allRecords.filter(record => record.facilityId === facilityId);
    return { success: true, data: facilityCmsCertifications };
  } catch (error) {
    return { success: false, message: `Failed to list facility CMS certifications: ${error.message}` };
  }
}

/**
 * Retrieves a specific facility CMS certification record by its ID and facility ID.
 * @param {string} facilityId The ID of the facility the CMS certification belongs to.
 * @param {string} cmsCertificationId The ID of the CMS certification record to retrieve.
 * @returns {object} An object containing success status and CMS certification data.
 */
function getFacilityCmsCertificationInfo(facilityId, cmsCertificationId) {
  try {
    if (!facilityId || !cmsCertificationId) {
      return { success: false, message: "Facility ID and CMS Certification ID are required to get CMS certification details." };
    }
    const sheet = getSheet(FACILITY_CMS_CERTIFICATIONS_SHEET_NAME, FACILITY_CMS_CERTIFICATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const cmsCertification = allRecords.find(record => record.facilityId === facilityId && record.id === cmsCertificationId);
    if (!cmsCertification) {
      return { success: false, message: `CMS Certification with ID ${cmsCertificationId} not found for facility ${facilityId}.` };
    }
    return { success: true, data: cmsCertification };
  } catch (error) {
    return { success: false, message: `Failed to retrieve facility CMS certification details: ${error.message}` };
  }
}

/**
 * Updates an existing facility CMS certification record.
 * @param {string} facilityId The ID of the facility the CMS certification belongs to.
 * @param {string} cmsCertificationId The ID of the CMS certification record to update.
 * @param {object} cmsCertificationData The data to patch.
 * @returns {object} A success or error message.
 */
function patchFacilityCmsCertificationInfo(facilityId, cmsCertificationId, cmsCertificationData) {
  try {
    const getResult = getFacilityCmsCertificationInfo(facilityId, cmsCertificationId);
    if (!getResult.success) { return getResult; }

    const result = patchDetailedInfo(FACILITY_CMS_CERTIFICATIONS_SHEET_NAME, cmsCertificationId, cmsCertificationData);
    if (result.success) {
      logAuditEvent("Request", `Facility CMS certification updated: ${cmsCertificationId}`, { facilityId: facilityId, cmsCertificationId: cmsCertificationId, newData: cmsCertificationData });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to update facility CMS certification ${cmsCertificationId}: ${error.message}`);
    return { success: false, message: `Failed to update facility CMS certification: ${error.message}` };
  }
}

/**
 * Deletes a facility CMS certification record.
 * @param {string} facilityId The ID of the facility the CMS certification belongs to.
 * @param {string} cmsCertificationId The ID of the CMS certification record to delete.
 * @returns {object} A success or error message.
 */
function deleteFacilityCmsCertificationInfo(facilityId, cmsCertificationId) {
  try {
    const getResult = getFacilityCmsCertificationInfo(facilityId, cmsCertificationId);
    if (!getResult.success) { return getResult; }

    const result = deleteDetailedProviderInfo(FACILITY_CMS_CERTIFICATIONS_SHEET_NAME, FACILITY_CMS_CERTIFICATIONS_HEADERS, cmsCertificationId);
    if (result.success) { logAuditEvent("Request", `Facility CMS certification deleted: ${cmsCertificationId}`, { facilityId: facilityId, cmsCertificationId: cmsCertificationId }); }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to delete facility CMS certification ${cmsCertificationId}: ${error.message}`);
    return { success: false, message: `Failed to delete facility CMS certification: ${error.message}` };
  }
}

// --- Facility Medicare Enrollments Functions ---

/**
 * Creates a new facility Medicare enrollment record.
 * @param {string} facilityId The ID of the facility the Medicare enrollment belongs to.
 * @param {object} medicareEnrollmentData The data for the new Medicare enrollment (medicareNumber, effectiveDate, terminationDate, enrollmentStatus).
 * @returns {object} A success or error message.
 */
function createFacilityMedicareEnrollmentInfo(facilityId, medicareEnrollmentData) {
  if (!facilityId || !medicareEnrollmentData || !medicareEnrollmentData.medicareNumber) {
    return { success: false, message: "Facility ID and Medicare number are required." };
  }
  const rowData = [
      medicareEnrollmentData.medicareNumber,
      medicareEnrollmentData.effectiveDate || "",
      medicareEnrollmentData.terminationDate || "",
      medicareEnrollmentData.enrollmentStatus || ""
  ];
  return createSubEntity(
    FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME,
    FACILITY_MEDICARE_ENROLLMENTS_HEADERS,
    facilityId,
    rowData,
    `Facility Medicare Enrollment "${medicareEnrollmentData.medicareNumber}"`
  );
}

/**
 * Retrieves a list of Medicare enrollment records for a given facility.
 * @param {string} facilityId The ID of the facility to retrieve Medicare enrollment records for.
 * @returns {object} An object containing success status and Medicare enrollment data.
 */
function listFacilityMedicareEnrollmentInfo(facilityId) {
  try {
    if (!facilityId) {
      return { success: false, message: "Facility ID is required to list Medicare enrollments." };
    }
    const sheet = getSheet(FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME, FACILITY_MEDICARE_ENROLLMENTS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const facilityMedicareEnrollments = allRecords.filter(record => record.facilityId === facilityId);
    return { success: true, data: facilityMedicareEnrollments };
  } catch (error) {
    return { success: false, message: `Failed to list facility Medicare enrollments: ${error.message}` };
  }
}

/**
 * Retrieves a specific facility Medicare enrollment record by its ID and facility ID.
 * @param {string} facilityId The ID of the facility the Medicare enrollment belongs to.
 * @param {string} medicareEnrollmentId The ID of the Medicare enrollment record to retrieve.
 * @returns {object} An object containing success status and Medicare enrollment data.
 */
function getFacilityMedicareEnrollmentInfo(facilityId, medicareEnrollmentId) {
  try {
    if (!facilityId || !medicareEnrollmentId) {
      return { success: false, message: "Facility ID and Medicare Enrollment ID are required to get Medicare enrollment details." };
    }
    const sheet = getSheet(FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME, FACILITY_MEDICARE_ENROLLMENTS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const medicareEnrollment = allRecords.find(record => record.facilityId === facilityId && record.id === medicareEnrollmentId);
    if (!medicareEnrollment) {
      return { success: false, message: `Medicare Enrollment with ID ${medicareEnrollmentId} not found for facility ${facilityId}.` };
    }
    return { success: true, data: medicareEnrollment };
  } catch (error) {
    return { success: false, message: `Failed to retrieve facility Medicare enrollment details: ${error.message}` };
  }
}

/**
 * Updates an existing facility Medicare enrollment record.
 * @param {string} facilityId The ID of the facility the Medicare enrollment belongs to.
 * @param {string} medicareEnrollmentId The ID of the Medicare enrollment record to update.
 * @param {object} medicareEnrollmentData The data to patch.
 * @returns {object} A success or error message.
 */
function patchFacilityMedicareEnrollmentInfo(facilityId, medicareEnrollmentId, medicareEnrollmentData) {
  try {
    const getResult = getFacilityMedicareEnrollmentInfo(facilityId, medicareEnrollmentId);
    if (!getResult.success) { return getResult; }

    const result = patchDetailedInfo(FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME, medicareEnrollmentId, medicareEnrollmentData);
    if (result.success) {
      logAuditEvent("Request", `Facility Medicare enrollment updated: ${medicareEnrollmentId}`, { facilityId: facilityId, medicareEnrollmentId: medicareEnrollmentId, newData: medicareEnrollmentData });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to update facility Medicare enrollment ${medicareEnrollmentId}: ${error.message}`);
    return { success: false, message: `Failed to update facility Medicare enrollment: ${error.message}` };
  }
}

/**
 * Deletes a facility Medicare enrollment record.
 * @param {string} facilityId The ID of the facility the Medicare enrollment belongs to.
 * @param {string} medicareEnrollmentId The ID of the Medicare enrollment record to delete.
 * @returns {object} A success or error message.
 */
function deleteFacilityMedicareEnrollmentInfo(facilityId, medicareEnrollmentId) {
  try {
    const getResult = getFacilityMedicareEnrollmentInfo(facilityId, medicareEnrollmentId);
    if (!getResult.success) { return getResult; }

    const result = deleteDetailedProviderInfo(FACILITY_MEDICARE_ENROLLMENTS_SHEET_NAME, FACILITY_MEDICARE_ENROLLMENTS_HEADERS, medicareEnrollmentId);
    if (result.success) { logAuditEvent("Request", `Facility Medicare enrollment deleted: ${medicareEnrollmentId}`, { facilityId: facilityId, medicareEnrollmentId: medicareEnrollmentId }); }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to delete facility Medicare enrollment ${medicareEnrollmentId}: ${error.message}`);
    return { success: false, message: `Failed to delete facility Medicare enrollment: ${error.message}` };
  }
}

// --- Facility Profiles Functions ---

/**
 * Lists available facility profile import sources.
 * @returns {object} An object containing success status and a list of import sources.
 */
function listFacilityProfileImportSources() {
  try {
    const sheet = getSheet(FACILITY_PROFILE_IMPORT_SOURCES_SHEET_NAME, FACILITY_PROFILE_IMPORT_SOURCES_HEADERS);
    const sources = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: sources };
  } catch (error) {
    logAuditEvent("Error", `Failed to list facility profile import sources: ${error.message}`);
    return { success: false, message: `Failed to list facility profile import sources: ${error.message}` };
  }
}

/**
 * Creates a new facility profile import job.
 * @param {object} importData The data for the new import (facilityId, source, parameters).
 * @returns {object} A success or error message, with the new import data on success.
 */
function createFacilityProfileImport(importData) {
  try {
    if (!importData.facilityId || !importData.source) {
      return { success: false, message: "Facility ID and source are required for profile import." };
    }

    const sheet = getSheet(FACILITY_PROFILE_IMPORTS_SHEET_NAME, FACILITY_PROFILE_IMPORTS_HEADERS);
    const newId = Utilities.getUuid();
    const now = new Date().toISOString();

    const status = "Completed"; // Simulate immediate completion
    const completedAt = now;

    const rowData = [
      newId,
      importData.facilityId,
      importData.source,
      status,
      now,
      completedAt,
      "", // Failure Code
      "", // Failure Reason
      JSON.stringify(importData.profileData || {}) // Mock profile data
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    logAuditEvent("Request", `Facility profile import created: ${newId} for facility ${importData.facilityId} from ${importData.source}`, { facilityId: importData.facilityId, importId: newId, source: importData.source });
    return { success: true, message: `Facility profile import created with ID: ${newId}`, data: { id: newId, status: status } };
  } catch (error) {
    logAuditEvent("Error", `Failed to create facility profile import: ${error.message}`);
    return { success: false, message: `Failed to create facility profile import: ${error.message}` };
  }
}

/**
 * Retrieves details for a specific facility profile import job.
 * @param {string} importId The ID of the import job to retrieve.
 * @returns {object} An object containing success status and the import job data.
 */
function getFacilityProfileImport(importId) {
  try {
    if (!importId) {
      return { success: false, message: "Import ID is required." };
    }
    const sheet = getSheet(FACILITY_PROFILE_IMPORTS_SHEET_NAME, FACILITY_PROFILE_IMPORTS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const importJob = allRecords.find(record => record.id === importId);
    if (!importJob) {
      return { success: false, message: `Facility profile import with ID ${importId} not found.` };
    }
    return { success: true, data: importJob };
  } catch (error) {
    logAuditEvent("Error", `Failed to get facility profile import ${importId}: ${error.message}`);
    return { success: false, message: `Failed to get facility profile import: ${error.message}` };
  }
}

/**
 * Lists facility profile import jobs with filtering and pagination.
 * @param {object} options - An object with pagination, sorting, and filtering parameters.
 * @param {number} [options.page=1] - The page number to retrieve.
 * @param {number} [options.pageSize=15] - The number of records per page.
 * @param {string} [options.facilityId] - Filter by facility ID.
 * @param {string} [options.source] - Filter by import source.
 * @param {string} [options.status] - Filter by import status.
 * @returns {object} An object with the list of import jobs and pagination info.
 */
function listFacilityProfileImports(options = {}) {
  try {
    const { page = 1, pageSize = 15, facilityId, source, status } = options;
    const sheet = getSheet(FACILITY_PROFILE_IMPORTS_SHEET_NAME, FACILITY_PROFILE_IMPORTS_HEADERS);
    let allImports = sheetDataToObjects(sheet.getDataRange().getValues());

    if (facilityId) {
      allImports = allImports.filter(job => job.facilityId === facilityId);
    }
    if (source) {
      allImports = allImports.filter(job => job.source === source);
    }
    if (status) {
      allImports = allImports.filter(job => job.status === status);
    }

    // Sort by 'Started' date, newest first
    allImports.sort((a, b) => new Date(b.started) - new Date(a.started));

    const totalRecords = allImports.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allImports.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list facility profile imports: ${error.message}`);
    return { success: false, message: `Failed to list facility profile imports: ${error.message}` };
  }
}

// --- Datasets Functions ---

/**
 * Simulates starting a dataset scan, finding a match, and creating an alert.
 * @param {object} body The request body containing scan details.
 * @param {string} body.type The type of dataset to scan (e.g., 'OigExclusions').
 * @param {string} [body.providerId] The ID of the provider to scan.
 * @param {string} [body.facilityId] The ID of the facility to scan.
 * @returns {object} An object containing success status and the created scan data.
 */
function startDatasetScan(body) {
  try {
    if (!body.type || (!body.providerId && !body.facilityId)) {
      return { success: false, message: "Dataset type and either providerId or facilityId are required." };
    }

    const scansSheet = getSheet(DATASET_SCANS_SHEET_NAME, DATASET_SCANS_HEADERS);
    const matchesSheet = getSheet(DATASET_MATCHES_SHEET_NAME, DATASET_MATCHES_HEADERS);
    const alertsSheet = getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS);

    const scanId = Utilities.getUuid();
    const now = new Date();
    const startTime = now.toISOString();
    
    // Log initial "Working" status
    let scanRowData = [
      scanId, body.type, body.providerId || "", body.facilityId || "", "Working", startTime, "", "Manual",
      JSON.stringify(body.options || {}), "", "", "{}", "[]", "", "", "{}"
    ];
    scansSheet.appendRow(scanRowData);
    invalidateRowIndexCache(scansSheet);

    // --- Simulate finding a match ---
    const matchId = Utilities.getUuid();
    const matchData = {
      id: matchId,
      datasetTimestamp: startTime,
      recordTimestamp: startTime,
      data: { Name: "JOHN DOE", Address: "123 FAKE ST", Reason: "Fraud" },
      scanId: scanId,
      userActionNeeded: true,
      isIgnored: false,
      matchScore: { score: 0.95, recommendation: "Match" },
      matchRelevance: "High",
      createdTimestamp: startTime
    };
    
    const matchRowData = [
      matchData.id, matchData.datasetTimestamp, matchData.recordTimestamp, JSON.stringify(matchData.data),
      matchData.scanId, matchData.userActionNeeded, matchData.isIgnored, JSON.stringify(matchData.matchScore),
      "", "", matchData.matchRelevance, matchData.createdTimestamp, ""
    ];
    matchesSheet.appendRow(matchRowData);
    invalidateRowIndexCache(matchesSheet);

    // --- Simulate creating an alert for the match ---
    const alertId = Utilities.getUuid();
    const alertData = {
      id: alertId,
      providerId: body.providerId || "",
      facilityId: body.facilityId || "",
      type: "DatasetMatchFound",
      entityType: "DatasetRecord",
      entityId: matchId,
      timestamp: startTime,
      data: { messageTemplate: `High relevance match found in ${body.type} scan.` }
    };
    const alertRowData = [
      alertData.id, alertData.providerId, alertData.type, alertData.entityType, alertData.entityId,
      alertData.timestamp, "", "", JSON.stringify(alertData.data)
    ];
    alertsSheet.appendRow(alertRowData);
    invalidateRowIndexCache(alertsSheet);

    // --- Update the scan to "Completed" ---
    const completedTime = new Date().toISOString();
    const scanResult = {
      id: scanId,
      status: "Completed",
      completed: completedTime,
      matches: [matchData] // Embed the match info
    };
    
    const idColIndex = DATASET_SCANS_HEADERS.indexOf("ID");
    const rowIndexMap = getOrCreateRowIndex(scansSheet, idColIndex);
    const rowNum = rowIndexMap.get(scanId);
    if (rowNum) {
      scansSheet.getRange(rowNum, DATASET_SCANS_HEADERS.indexOf("Status") + 1).setValue(scanResult.status);
      scansSheet.getRange(rowNum, DATASET_SCANS_HEADERS.indexOf("Completed") + 1).setValue(scanResult.completed);
      scansSheet.getRange(rowNum, DATASET_SCANS_HEADERS.indexOf("Matches (JSON)") + 1).setValue(JSON.stringify(scanResult.matches));
    }
    
    logAuditEvent("Request", `Dataset scan completed for ${body.providerId || body.facilityId}`, { scanId: scanId, type: body.type });
    return { success: true, data: scanResult };

  } catch (error) {
    logAuditEvent("Error", `Failed to start dataset scan: ${error.message}`);
    return { success: false, message: `Failed to start dataset scan: ${error.message}` };
  }
}

function listDatasetScans(query = {}) {
  try {
    const sheet = getSheet(DATASET_SCANS_SHEET_NAME, DATASET_SCANS_HEADERS);
    let allScans = sheetDataToObjects(sheet.getDataRange().getValues());

    if (query.providerId) {
      allScans = allScans.filter(s => s.providerId === query.providerId);
    }
    if (query.facilityId) {
      allScans = allScans.filter(s => s.facilityId === query.facilityId);
    }
    if (query.type) {
      allScans = allScans.filter(s => s.type === query.type);
    }
    // Add more filters as needed

    return { success: true, data: allScans };
  } catch (error) {
    logAuditEvent("Error", `Failed to list dataset scans: ${error.message}`);
    return { success: false, message: `Failed to list dataset scans: ${error.message}` };
  }
}

function listDatasetMatches(query = {}) {
  try {
    const sheet = getSheet(DATASET_MATCHES_SHEET_NAME, DATASET_MATCHES_HEADERS);
    let allMatches = sheetDataToObjects(sheet.getDataRange().getValues());

    if (query.scanId) {
      allMatches = allMatches.filter(m => m.scanId === query.scanId);
    }
    if (query.userActionNeeded) {
      allMatches = allMatches.filter(m => m.userActionNeeded === true);
    }
    // Add more filters as needed

    return { success: true, data: allMatches };
  } catch (error) {
    logAuditEvent("Error", `Failed to list dataset matches: ${error.message}`);
    return { success: false, message: `Failed to list dataset matches: ${error.message}` };
  }
}

function patchDatasetMatch(matchId, body) {
  try {
    const result = patchDetailedInfo(DATASET_MATCHES_SHEET_NAME, matchId, body);
    if (result.success) {
      logAuditEvent("Request", `Dataset match patched: ${matchId}`, { matchId: matchId, newData: body });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to patch dataset match ${matchId}: ${error.message}`);
    return { success: false, message: `Failed to patch dataset match: ${error.message}` };
  }
}

// --- Monitoring Functions ---

function createMonitor(body) {
  try {
    if (!body.type || !body.providerId || (!body.datasetType && !body.licenseId)) {
      return { success: false, message: "Type, providerId, and either datasetType or licenseId are required." };
    }
    const sheet = getSheet(MONITORS_SHEET_NAME, MONITORS_HEADERS);
    const newId = Utilities.getUuid();
    const now = new Date();
    const nextMonitoringDate = new Date(now.setDate(now.getDate() + 30)).toISOString(); // Default to 30 days

    const rowData = [
      newId, body.type, body.providerId, body.datasetType || "", body.licenseId || "",
      body.monitoringInterval || "Monthly", nextMonitoringDate, "", "", JSON.stringify(body.options || {})
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    logAuditEvent("Request", `Monitor created for provider ${body.providerId}`, { monitorId: newId, type: body.type });
    return { success: true, message: `Monitor created with ID: ${newId}` };
  } catch (error) {
    logAuditEvent("Error", `Failed to create monitor: ${error.message}`);
    return { success: false, message: `Failed to create monitor: ${error.message}` };
  }
}

function listMonitors(query = {}) {
  try {
    const sheet = getSheet(MONITORS_SHEET_NAME, MONITORS_HEADERS);
    let allMonitors = sheetDataToObjects(sheet.getDataRange().getValues());

    if (query.providerId) {
      allMonitors = allMonitors.filter(m => m.providerId === query.providerId);
    }
    // Add more filters as needed

    return { success: true, data: allMonitors };
  } catch (error) {
    logAuditEvent("Error", `Failed to list monitors: ${error.message}`);
    return { success: false, message: `Failed to list monitors: ${error.message}` };
  }
}

function deleteMonitor(monitorId) {
  const result = deleteDetailedProviderInfo(MONITORS_SHEET_NAME, MONITORS_HEADERS, monitorId);
  if (result.success) {
    logAuditEvent("Request", `Monitor deleted: ${monitorId}`, { monitorId: monitorId });
  }
  return result;
}

// --- Alerts Functions ---

function listAlerts(query = {}) {
  try {
    const sheet = getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS);
    let allAlerts = sheetDataToObjects(sheet.getDataRange().getValues());

    if (query.providerId) {
      allAlerts = allAlerts.filter(a => a.providerId === query.providerId);
    }
    if (query.status === 'active') {
      allAlerts = allAlerts.filter(a => !a.dismissalTimestamp);
    } else if (query.status === 'dismissed') {
      allAlerts = allAlerts.filter(a => !!a.dismissalTimestamp);
    }
    // Add more filters as needed

    return { success: true, data: allAlerts };
  } catch (error) {
    logAuditEvent("Error", `Failed to list alerts: ${error.message}`);
    return { success: false, message: `Failed to list alerts: ${error.message}` };
  }
}

function dismissAlert(alertId, body) {
  try {
    const dataToUpdate = {
      dismissalTimestamp: new Date().toISOString(),
      dismissalNote: body.dismissalNote || ""
    };
    const result = patchDetailedInfo(ALERTS_SHEET_NAME, alertId, dataToUpdate);
    if (result.success) {
      logAuditEvent("Request", `Alert dismissed: ${alertId}`, { alertId: alertId });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to dismiss alert ${alertId}: ${error.message}`);
    return { success: false, message: `Failed to dismiss alert: ${error.message}` };
  }
}

// --- Licenses Functions ---

/**
 * Lists available license types.
 * @returns {object} An object containing success status and a list of license types.
 */
function listSimplifiedLicenseTypes() {
  try {
    const sheet = getSheet(LICENSE_TYPES_SHEET_NAME, LICENSE_TYPES_HEADERS);
    const licenseTypes = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: licenseTypes };
  } catch (error) {
    logAuditEvent("Error", `Failed to list license types: ${error.message}`);
    return { success: false, message: `Failed to list license types: ${error.message}` };
  }
}

/**
 * Attaches a new license to a provider.
 * @param {string} providerId The ID of the provider.
 * @param {object} body The license data.
 * @returns {object} An object containing success status and the new license data.
 */
function attachLicense(providerId, body) {
  try {
    if (!providerId || !body || !body.licenseTypeId || !body.state) {
      return { success: false, message: "Provider ID, License Type ID, and State are required." };
    }
    const sheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    const newId = Utilities.getUuid();
    const nonVerifiedInfo = body.nonVerifiedInfo || {};

    const rowData = [
      newId, providerId, body.licenseNumber || "", body.firstName || "", body.lastName || "",
      body.state, "Idle", nonVerifiedInfo.issueDate || "", nonVerifiedInfo.expirationDate || "",
      nonVerifiedInfo.status || "", "Pending", "", body.restrictionStatus || "None",
      body.approvedStatus || "Pending", body.isPrimary || false, body.isCurrentlyPracticing || false,
      body.prescriptiveAuthority || "NotRequired", body.collaboratingProviderId || "", body.licenseTypeId
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    if (!body.skipVerification) {
      triggerLicenseVerification(providerId, newId);
    }

    logAuditEvent("Request", `License attached for provider ${providerId}`, { providerId: providerId, licenseId: newId });
    const newLicense = getLicense(providerId, newId).data; // Fetch the newly created license to return it
    return { success: true, data: newLicense };
  } catch (error) {
    logAuditEvent("Error", `Failed to attach license for provider ${providerId}: ${error.message}`);
    return { success: false, message: `Failed to attach license: ${error.message}` };
  }
}

/**
 * Triggers a new verification for a license.
 * @param {string} providerId The ID of the provider.
 * @param {string} licenseId The ID of the license to verify.
 * @returns {object} A success or error message.
 */
function triggerLicenseVerification(providerId, licenseId) {
  try {
    const verificationsSheet = getSheet(LICENSE_VERIFICATIONS_SHEET_NAME, LICENSE_VERIFICATIONS_HEADERS);
    const newVerificationId = Utilities.getUuid();
    const now = new Date().toISOString();

    // Simulate a verification result
    const mockResult = {
      name: "Mock Verified Name",
      licenseStatus: "Active",
      expires: new Date(new Date().setFullYear(new Date().getFullYear() + 2)).toISOString(),
      matchScore: { score: 1.0, recommendation: "Match" }
    };

    const rowData = [
      newVerificationId, licenseId, providerId, "Found", "Found", "Manual", now, 1500,
      JSON.stringify([mockResult]), "{}", JSON.stringify({name: "Mock Source", url: "https://mock.source.com"}), "{}", null, "", "{}"
    ];
    verificationsSheet.appendRow(rowData);
    invalidateRowIndexCache(verificationsSheet);

    // Update the license record with the latest verification info
    const licensesSheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    const idColIndex = LICENSES_HEADERS.indexOf("ID");
    const rowIndexMap = getOrCreateRowIndex(licensesSheet, idColIndex);
    const rowNum = rowIndexMap.get(licenseId);
    if (rowNum) {
      licensesSheet.getRange(rowNum, LICENSES_HEADERS.indexOf("Current Verification Status") + 1).setValue("Found");
      licensesSheet.getRange(rowNum, LICENSES_HEADERS.indexOf("Current Verification ID") + 1).setValue(newVerificationId);
      // Update other relevant license fields from mockResult if needed, e.g., expiration date
      // licensesSheet.getRange(rowNum, LICENSES_HEADERS.indexOf("Non Verified Expiration Date") + 1).setValue(mockResult.expires.split('T')[0]);
      invalidateRowIndexCache(licensesSheet);
    }

    logAuditEvent("Request", `License verification triggered for license ${licenseId}`, { providerId: providerId, licenseId: licenseId, verificationId: newVerificationId });
    return { success: true, message: `Verification triggered for license ${licenseId}.` };
  } catch (error) {
    logAuditEvent("Error", `Failed to trigger license verification for ${licenseId}: ${error.message}`);
    return { success: false, message: `Failed to trigger license verification: ${error.message}` };
  }
}

/**
 * Lists all historical verifications for a single license.
 * @param {string} providerId The ID of the provider.
 * @param {string} licenseId The ID of the license.
 * @returns {object} An object containing success status and a list of verification data.
 */
function listLicenseVerifications(providerId, licenseId) {
  try {
    if (!providerId || !licenseId) {
      return { success: false, message: "Provider ID and License ID are required to list verifications." };
    }
    const sheet = getSheet(LICENSE_VERIFICATIONS_SHEET_NAME, LICENSE_VERIFICATIONS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const licenseVerifications = allRecords.filter(record => record.providerId === providerId && record.licenseId === licenseId);

    // Sort by timestamp descending (newest first)
    licenseVerifications.sort((a, b) => new Date(b.started) - new Date(a.started));

    return { success: true, data: licenseVerifications };
  } catch (error) {
    logAuditEvent("Error", `Failed to list verifications for license ${licenseId}: ${error.message}`);
    return { success: false, message: `Failed to list license verifications: ${error.message}` };
  }
}

/**
 * Retrieves a single, specific verification record.
 * @param {string} providerId The ID of the provider.
 * @param {string} licenseId The ID of the license.
 * @param {string} verificationId The ID of the verification to retrieve.
 * @returns {object} An object containing success status and the verification data.
 */
function getLicenseVerification(providerId, licenseId, verificationId) {
  try {
    if (!providerId || !licenseId || !verificationId) {
      return { success: false, message: "Provider ID, License ID, and Verification ID are required." };
    }
    const sheet = getSheet(LICENSE_VERIFICATIONS_SHEET_NAME, LICENSE_VERIFICATIONS_HEADERS);
    const allVerifications = sheetDataToObjects(sheet.getDataRange().getValues());
    const verification = allVerifications.find(v => v.providerId === providerId && v.licenseId === licenseId && v.id === verificationId);
    if (!verification) {
      return { success: false, message: `Verification with ID ${verificationId} not found.` };
    }
    return { success: true, data: verification };
  } catch (error) {
    logAuditEvent("Error", `Failed to get license verification ${verificationId}: ${error.message}`);
    return { success: false, message: `Failed to get license verification: ${error.message}` };
  }
}

/**
 * Patches a verification to resolve a "NeedsReview" status.
 * @param {string} verificationId The ID of the verification record to update.
 * @param {object} body The data to patch (e.g., status, correctResultIndex).
 * @returns {object} A success or error message.
 */
function resolveLicenseVerificationProblems(verificationId, body) {
  try {
    const dataToUpdate = {
      status: body.status, // Should be 'Found', 'NotFound', or 'Failed' after resolution
      correctResultIndex: body.correctResultIndex || null, // Index of the correct result from 'results (JSON)'
      // You might also want to add a 'resolutionNote' or 'resolvedBy'
    };

    const result = patchDetailedInfo(LICENSE_VERIFICATIONS_SHEET_NAME, verificationId, dataToUpdate);

    if (result.success) {
      // If the resolution changes the status to "Found", also update the main license status
      const verificationsSheet = getSheet(LICENSE_VERIFICATIONS_SHEET_NAME, LICENSE_VERIFICATIONS_HEADERS);
      const allVerifications = sheetDataToObjects(verificationsSheet.getDataRange().getValues());
      const updatedVerification = allVerifications.find(v => v.id === verificationId);

      if (updatedVerification && updatedVerification.status === "Found") {
        const licensesSheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
        const licenseId = updatedVerification.licenseId;
        const licenseIdColIndex = LICENSES_HEADERS.indexOf("ID");
        const licenseRowNum = getOrCreateRowIndex(licensesSheet, licenseIdColIndex).get(licenseId);

        if (licenseRowNum) {
          licensesSheet.getRange(licenseRowNum, LICENSES_HEADERS.indexOf("Current Verification Status") + 1).setValue("Found");
          licensesSheet.getRange(licenseRowNum, LICENSES_HEADERS.indexOf("Current Verification ID") + 1).setValue(verificationId);
          invalidateRowIndexCache(licensesSheet);
        }
      }

      logAuditEvent("Request", `License verification ${verificationId} resolved to ${body.status}`, { verificationId: verificationId, newStatus: body.status });
    } else {
      logAuditEvent("Error", `Failed to resolve license verification ${verificationId}: ${result.message}`);
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to resolve license verification: ${error.message}`);
    return { success: false, message: `Failed to resolve license verification: ${error.message}` };
  }
}



/**
 * Updates an existing license record.
 * Note: This function does not check provider ownership as per the API spec.
 * @param {string} licenseId The ID of the license to update.
 * @param {object} body The data to patch.
 * @returns {object} A success or error message.
 */
function patchLicense(licenseId, body) {
  try {
    const result = patchDetailedInfo(LICENSES_SHEET_NAME, licenseId, body);
    if (result.success) {
      logAuditEvent("Request", `License patched: ${licenseId}`, { licenseId: licenseId, newData: body });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to patch license ${licenseId}: ${error.message}`);
    return { success: false, message: `Failed to patch license: ${error.message}` };
  }
}

function listProviderLicenses(options = {}) {
  try {
    const { page = 1, pageSize = 15, searchTerm = '', status = '', state = '', licenseTypeId = '', sortBy = 'licenseNumber', sortOrder = 'asc' } = options;

    const licensesSheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    let allLicenses = sheetDataToObjects(licensesSheet.getDataRange().getValues());

    // Filter by search term
    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allLicenses = allLicenses.filter(l =>
        (l.licenseNumber && l.licenseNumber.toLowerCase().includes(lowercasedTerm)) ||
        (l.firstName && l.firstName.toLowerCase().includes(lowercasedTerm)) ||
        (l.lastName && l.lastName.toLowerCase().includes(lowercasedTerm)) ||
        (l.state && l.state.toLowerCase().includes(lowercasedTerm)) ||
        (l.currentVerificationStatus && l.currentVerificationStatus.toLowerCase().includes(lowercasedTerm))
      );
    }

    // Filter by specific criteria
    if (status) {
      allLicenses = allLicenses.filter(l => l.currentVerificationStatus === status);
    }
    if (state) {
      allLicenses = allLicenses.filter(l => l.state === state);
    }
    if (licenseTypeId) {
      allLicenses = allLicenses.filter(l => l.licenseTypeId === licenseTypeId);
    }

    // Enrich with Provider Names and License Type Names
    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
    const providerMap = new Map(allProviders.map(p => [p.id, `${p.firstName} ${p.lastName}`]));

    const licenseTypesSheet = getSheet(LICENSE_TYPES_SHEET_NAME, LICENSE_TYPES_HEADERS);
    const allLicenseTypes = sheetDataToObjects(licenseTypesSheet.getDataRange().getValues());
    const licenseTypeMap = new Map(allLicenseTypes.map(lt => [lt.id, lt.name]));

    allLicenses.forEach(license => {
      license.providerName = providerMap.get(license.providerId) || 'Unknown Provider';
      license.licenseTypeName = licenseTypeMap.get(license.licenseTypeId) || 'Unknown Type';
    });


    // Sorting
    allLicenses.sort((a, b) => {
      const valA = a[sortBy] || '';
      const valB = b[sortBy] || '';

      let comparison = 0;
      if (sortBy.includes('Date')) { // Assuming date fields end with 'Date'
        comparison = new Date(valA) > new Date(valB) ? 1 : -1;
      } else {
        if (String(valA).toLowerCase() > String(valB).toLowerCase()) {
          comparison = 1;
        } else if (String(valA).toLowerCase() < String(valB).toLowerCase()) {
          comparison = -1;
        }
      }
      return sortOrder === 'desc' ? comparison * -1 : comparison;
    });

    const totalRecords = allLicenses.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allLicenses.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };

  } catch (error) {
    logAuditEvent("Error", `Failed to list provider licenses: ${error.message}`);
    return { success: false, message: `Failed to list provider licenses: ${error.message}` };
  }
}

/**
 * Detaches a license from a provider, deleting the license and its associated records.
 * @param {string} providerId The ID of the provider.
 * @param {string} licenseId The ID of the license to detach.
 * @returns {object} A success or error message.
 */
function detachLicense(providerId, licenseId) {
  try {
    // First, verify the license belongs to the provider for security.
    const sheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    const allLicenses = sheetDataToObjects(sheet.getDataRange().getValues());
    const license = allLicenses.find(l => l.id === licenseId && l.providerId === providerId);
    if (!license) {
      return { success: false, message: `License with ID ${licenseId} not found for provider ${providerId}.` };
    }

    // Delete associated verifications
    const verificationsSheet = getSheet(LICENSE_VERIFICATIONS_SHEET_NAME, LICENSE_VERIFICATIONS_HEADERS);
    const verificationLicenseIdCol = LICENSE_VERIFICATIONS_HEADERS.indexOf("License ID");
    deleteRowsByColumnValue(verificationsSheet, verificationLicenseIdCol, licenseId);

    // Delete associated monitors
    const monitorsSheet = getSheet(MONITORS_SHEET_NAME, MONITORS_HEADERS);
    const monitorLicenseIdCol = MONITORS_HEADERS.indexOf("License ID");
    deleteRowsByColumnValue(monitorsSheet, monitorLicenseIdCol, licenseId);

    // Delete the license itself
    const result = deleteDetailedProviderInfo(LICENSES_SHEET_NAME, LICENSES_HEADERS, licenseId);
    if (result.success) {
      logAuditEvent("Request", `License detached: ${licenseId}`, { providerId: providerId, licenseId: licenseId });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to detach license ${licenseId}: ${error.message}`);
    return { success: false, message: `Failed to detach license: ${error.message}` };
  }
}

// --- Groups Functions ---

// ... (existing functions like createGroup, listGroups, getGroup, patchGroup, deleteGroup)

/**
 * Retrieves details for a specific group, including its associated providers and payers.
 * @param {string} groupId The ID of the group to retrieve.
 * @returns {object} An object containing success status and the group data with related entities.
 */
function getGroupDetails(groupId) {
  try {
    const groupsSheet = getSheet(GROUPS_SHEET_NAME, GROUPS_HEADERS);
    const group = sheetDataToObjects(groupsSheet.getDataRange().getValues()).find(g => g.id === groupId);
    if (!group) {
      return { success: false, message: `Group with ID ${groupId} not found.` };
    }

    // Fetch related providers
    const groupProvidersSheet = getSheet(GROUP_PROVIDERS_SHEET_NAME, GROUP_PROVIDERS_HEADERS);
    const allGroupProviders = sheetDataToObjects(groupProvidersSheet.getDataRange().getValues());
    const providerIdsInGroup = allGroupProviders.filter(gp => gp.groupId === groupId).map(gp => gp.providerId);

    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
    group.providers = allProviders.filter(p => providerIdsInGroup.includes(p.id));

    // Fetch related payers
    const groupPayersSheet = getSheet(GROUP_PAYERS_SHEET_NAME, GROUP_PAYERS_HEADERS);
    const allGroupPayers = sheetDataToObjects(groupPayersSheet.getDataRange().getValues());
    const payerIdsInGroup = allGroupPayers.filter(gp => gp.groupId === groupId).map(gp => gp.payerId);

    const payersSheet = getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS);
    const allPayers = sheetDataToObjects(payersSheet.getDataRange().getValues());
    group.payers = allPayers.filter(p => payerIdsInGroup.includes(p.id));

    return { success: true, data: group };
  } catch (error) {
    logAuditEvent("Error", `Failed to get group details for ${groupId}: ${error.message}`);
    return { success: false, message: `Failed to get group details: ${error.message}` };
  }
}

/**
 * Retrieves a specific payer by its ID, including its associated plans.
 * @param {string} payerId The ID of the payer to retrieve.
 * @returns {object} An object containing success status and the payer data with related plans.
 */
function getPayerDetails(payerId) {
  try {
    const payersSheet = getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS);
    const payer = sheetDataToObjects(payersSheet.getDataRange().getValues()).find(p => p.id === payerId);
    if (!payer) {
      return { success: false, message: `Payer with ID ${payerId} not found.` };
    }

    // Fetch related plans
    const plansSheet = getSheet(PAYER_PLANS_SHEET_NAME, PAYER_PLANS_HEADERS);
    const allPlans = sheetDataToObjects(plansSheet.getDataRange().getValues());
    payer.plans = allPlans.filter(p => p.payerId === payerId);

    return { success: true, data: payer };
  } catch (error) {
    logAuditEvent("Error", `Failed to get payer details for ${payerId}: ${error.message}`);
    return { success: false, message: `Failed to get payer details: ${error.message}` };
  }
}

/**
 * Attaches a new license to a provider.
 * @param {string} providerId The ID of the provider.
 * @param {object} body The license data.
 * @returns {object} An object containing success status and the new license data.
 */
function attachLicense(providerId, body) {
  try {
    if (!providerId || !body || !body.licenseTypeId || !body.state || !body.licenseNumber) {
      return { success: false, message: "Provider ID, License Type ID, State, and License Number are required." };
    }
    const sheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    const newId = Utilities.getUuid();

    const rowData = [
      newId, providerId, body.licenseNumber, "", "", body.state, "Idle", body.issueDate || "", body.expirationDate || "",
      body.status || "", "Pending", "", "None", "Pending", false, false, "NotRequired", "", body.licenseTypeId
    ];
    sheet.appendRow(rowData);
    invalidateRowIndexCache(sheet);

    logAuditEvent("Request", `License attached for provider ${providerId}`, { providerId: providerId, licenseId: newId });
    const newLicense = sheetDataToObjects(sheet.getDataRange().getValues()).find(l => l.id === newId);
    return { success: true, data: newLicense, message: "License attached successfully." };
  } catch (error) {
    logAuditEvent("Error", `Failed to attach license for provider ${providerId}: ${error.message}`);
    return { success: false, message: `Failed to attach license: ${error.message}` };
  }
}

/**
 * Detaches a license from a provider.
 * @param {string} providerId The ID of the provider.
 * @param {string} licenseId The ID of the license to detach.
 * @returns {object} A success or error message.
 */
function detachLicense(providerId, licenseId) {
  try {
    const sheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    const allLicenses = sheetDataToObjects(sheet.getDataRange().getValues());
    const license = allLicenses.find(l => l.id === licenseId && l.providerId === providerId);
    if (!license) {
      return { success: false, message: `License with ID ${licenseId} not found for provider ${providerId}.` };
    }

    const result = deleteDetailedProviderInfo(LICENSES_SHEET_NAME, LICENSES_HEADERS, licenseId);
    if (result.success) {
      logAuditEvent("Request", `License detached: ${licenseId}`, { providerId: providerId, licenseId: licenseId });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to detach license ${licenseId}: ${error.message}`);
    return { success: false, message: `Failed to detach license: ${error.message}` };
  }
}

/**
 * Simulates starting a dataset scan.
 * @param {object} body The request body containing scan details.
 * @returns {object} An object containing success status and the created scan data.
 */
function startDatasetScan(body) {
  try {
    if (!body.type || !body.providerId) {
      return { success: false, message: "Dataset type and providerId are required." };
    }

    const scansSheet = getSheet(DATASET_SCANS_SHEET_NAME, DATASET_SCANS_HEADERS);
    const alertsSheet = getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS);
    const scanId = Utilities.getUuid();
    const now = new Date();
    const startTime = now.toISOString();
    
    let scanRowData = [
      scanId, body.type, body.providerId, "", "Working", startTime, "", "Manual",
      JSON.stringify(body.options || {}), "", "", "{}", "[]", "", "", "{}"
    ];
    scansSheet.appendRow(scanRowData);
    invalidateRowIndexCache(scansSheet);

    // Simulate finding a match and creating an alert
    const alertId = Utilities.getUuid();
    const alertData = {
      id: alertId, providerId: body.providerId, type: "DatasetMatchFound", entityType: "DatasetScan",
      entityId: scanId, timestamp: startTime, data: { messageTemplate: `Mock match found in ${body.type} scan.` }
    };
    const alertRowData = [
      alertData.id, alertData.providerId, alertData.type, alertData.entityType, alertData.entityId,
      alertData.timestamp, "", "", JSON.stringify(alertData.data)
    ];
    alertsSheet.appendRow(alertRowData);
    invalidateRowIndexCache(alertsSheet);

    // Update the scan to "Completed"
    const completedTime = new Date(now.getTime() + 2000).toISOString(); // 2 seconds later
    const scanResult = { id: scanId, status: "Completed", completed: completedTime };
    
    const idColIndex = DATASET_SCANS_HEADERS.indexOf("ID");
    const rowIndexMap = getOrCreateRowIndex(scansSheet, idColIndex);
    const rowNum = rowIndexMap.get(scanId);
    if (rowNum) {
      scansSheet.getRange(rowNum, DATASET_SCANS_HEADERS.indexOf("Status") + 1).setValue(scanResult.status);
      scansSheet.getRange(rowNum, DATASET_SCANS_HEADERS.indexOf("Completed") + 1).setValue(scanResult.completed);
    }
    
    logAuditEvent("Request", `Dataset scan completed for ${body.providerId}`, { scanId: scanId, type: body.type });
    return { success: true, message: `Scan ${scanId} completed. An alert was generated.`, data: scanResult };

  } catch (error) {
    logAuditEvent("Error", `Failed to start dataset scan: ${error.message}`);
    return { success: false, message: `Failed to start dataset scan: ${error.message}` };
  }
}

/**
 * Lists alerts with filtering and pagination.
 * @param {object} [options={}] Query parameters.
 * @returns {object} An object with the list of alerts and pagination info.
 */
function listAlerts(options = {}) {
  try {
    const { page = 1, pageSize = 15, searchTerm = '', status = 'active' } = options;
    const sheet = getSheet(ALERTS_SHEET_NAME, ALERTS_HEADERS);
    let allAlerts = sheetDataToObjects(sheet.getDataRange().getValues());

    // Filter by status
    if (status === 'active') {
      allAlerts = allAlerts.filter(a => !a.dismissalTimestamp);
    } else if (status === 'dismissed') {
      allAlerts = allAlerts.filter(a => !!a.dismissalTimestamp);
    }

    // Enrich with provider/facility names
    const providers = sheetDataToObjects(getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS).getDataRange().getValues());
    const facilities = sheetDataToObjects(getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS).getDataRange().getValues());
    const providerMap = new Map(providers.map(p => [p.id, `${p.firstName} ${p.lastName}`]));
    const facilityMap = new Map(facilities.map(f => [f.id, f.name]));

    allAlerts.forEach(alert => {
      if (alert.providerId) {
        alert.entityName = providerMap.get(alert.providerId) || 'Unknown Provider';
      } else if (alert.facilityId) {
        alert.entityName = facilityMap.get(alert.facilityId) || 'Unknown Facility';
      }
    });

    // Filter by search term
    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allAlerts = allAlerts.filter(a => 
        (a.type && a.type.toLowerCase().includes(lowercasedTerm)) ||
        (a.entityId && a.entityId.toLowerCase().includes(lowercasedTerm)) ||
        (a.entityName && a.entityName.toLowerCase().includes(lowercasedTerm))
      );
    }

    // Sort by timestamp descending
    allAlerts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    const totalRecords = allAlerts.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allAlerts.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list alerts: ${error.message}`);
    return { success: false, message: `Failed to list alerts: ${error.message}` };
  }
}

/**
 * Dismisses an alert by updating its dismissal timestamp and note.
 * @param {string} alertId The ID of the alert to dismiss.
 * @param {object} body An object containing the dismissalNote.
 * @returns {object} A success or error message.
 */
function dismissAlert(alertId, body) {
  try {
    const dataToUpdate = {
      dismissalTimestamp: new Date().toISOString(),
      dismissalNote: body.dismissalNote || "Dismissed by user."
    };
    const result = patchDetailedInfo(ALERTS_SHEET_NAME, alertId, dataToUpdate);
    if (result.success) {
      logAuditEvent("Request", `Alert dismissed: ${alertId}`, { alertId: alertId });
    }
    return result;
  } catch (error) {
    logAuditEvent("Error", `Failed to dismiss alert ${alertId}: ${error.message}`);
    return { success: false, message: `Failed to dismiss alert: ${error.message}` };
  }
}

/**
 * Retrieves a specific payer by its ID.
 * @param {string} payerId The ID of the payer to retrieve.
 * @returns {object} An object containing success status and the payer data.
 */
function getPayer(payerId) {
  try {
    if (!payerId) {
      return { success: false, message: "Payer ID is required." };
    }
    const sheet = getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const payer = allRecords.find(record => record.id === payerId);
    if (!payer) {
      return { success: false, message: `Payer with ID ${payerId} not found.` };
    }
    return { success: true, data: payer };
  } catch (error) {
    logAuditEvent("Error", `Failed to retrieve payer ${payerId}: ${error.message}`);
    return { success: false, message: `Failed to retrieve payer: ${error.message}` };
  }
}

/**
 * Retrieves a specific payer plan by its ID.
 * @param {string} payerPlanId The ID of the payer plan to retrieve.
 * @returns {object} An object containing success status and the plan data.
 */
function getPayerPlan(payerPlanId) {
  try {
    if (!payerPlanId) {
      return { success: false, message: "Payer Plan ID is required." };
    }
    const sheet = getSheet(PAYER_PLANS_SHEET_NAME, PAYER_PLANS_HEADERS);
    const allRecords = sheetDataToObjects(sheet.getDataRange().getValues());
    const plan = allRecords.find(record => record.id === payerPlanId);
    if (!plan) {
      return { success: false, message: `Payer Plan with ID ${payerPlanId} not found.` };
    }
    // Enrich with Payer Name
    const payersSheet = getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS);
    const payers = sheetDataToObjects(payersSheet.getDataRange().getValues());
    const payer = payers.find(p => p.id === plan.payerId);
    if (payer) {
      plan.payerName = payer.name;
    }
    return { success: true, data: plan };
  } catch (error) {
    logAuditEvent("Error", `Failed to retrieve payer plan ${payerPlanId}: ${error.message}`);
    return { success: false, message: `Failed to retrieve payer plan: ${error.message}` };
  }
}

/**
 * Lists providers associated with a specific group, with pagination and sorting.
 * @param {string} groupId The ID of the group.
 * @param {object} [options={}] Query parameters for pagination, sorting, and searching.
 * @returns {object} An object with the list of providers and pagination info.
 */
function listGroupProviders(groupId, options = {}) {
  try {
    if (!groupId) {
      return { success: false, message: "Group ID is required." };
    }
    const { page = 1, pageSize = 15, searchTerm = '', sortBy = 'lastName', sortOrder = 'asc' } = options;

    const groupProvidersSheet = getSheet(GROUP_PROVIDERS_SHEET_NAME, GROUP_PROVIDERS_HEADERS);
    const groupProviderRelations = sheetDataToObjects(groupProvidersSheet.getDataRange().getValues());
    const providerIdsInGroup = new Set(groupProviderRelations.filter(gp => gp.groupId === groupId).map(gp => gp.providerId));

    if (providerIdsInGroup.size === 0) {
      return { success: true, data: [], totalRecords: 0 };
    }

    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    let allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
    let groupProviders = allProviders.filter(p => providerIdsInGroup.has(p.id));

    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      groupProviders = groupProviders.filter(p => {
        const fullName = `${p.firstName || ''} ${p.lastName || ''}`.toLowerCase();
        return (p.id && p.id.toLowerCase().includes(lowercasedTerm)) ||
               fullName.includes(lowercasedTerm) ||
               (p.npi && p.npi.toString().includes(lowercasedTerm));
      });
    }

    groupProviders.sort((a, b) => {
      const valA = a[sortBy] || '';
      const valB = b[sortBy] || '';
      let comparison = 0;
      if (valA > valB) {
        comparison = 1;
      } else if (valA < valB) {
        comparison = -1;
      }
      return sortOrder === 'desc' ? comparison * -1 : comparison;
    });

    const totalRecords = groupProviders.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = groupProviders.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list group providers for group ${groupId}: ${error.message}`);
    return { success: false, message: `Failed to list group providers: ${error.message}` };
  }
}

/**
 * Lists enrollments associated with a specific group, with pagination and sorting.
 * @param {string} groupId The ID of the group.
 * @param {object} [options={}] Query parameters for pagination and sorting.
 * @returns {object} An object with the list of enrollments and pagination info.
 */
function listGroupEnrollments(groupId, options = {}) {
  try {
    if (!groupId) {
      return { success: false, message: "Group ID is required." };
    }
    const { page = 1, pageSize = 15, sortBy = 'effectiveDate', sortOrder = 'desc' } = options;

    const enrollmentsSheet = getSheet(PROVIDER_ENROLLMENTS_SHEET_NAME, PROVIDER_ENROLLMENTS_HEADERS);
    let allEnrollments = sheetDataToObjects(enrollmentsSheet.getDataRange().getValues());
    let groupEnrollments = allEnrollments.filter(e => e.groupId === groupId);

    const providers = sheetDataToObjects(getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS).getDataRange().getValues());
    const plans = sheetDataToObjects(getSheet(PAYER_PLANS_SHEET_NAME, PAYER_PLANS_HEADERS).getDataRange().getValues());
    const payers = sheetDataToObjects(getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS).getDataRange().getValues());
    const providerMap = new Map(providers.map(p => [p.id, `${p.firstName} ${p.lastName}`]));
    const planMap = new Map(plans.map(p => [p.id, {name: p.name, payerId: p.payerId}]));
    const payerMap = new Map(payers.map(p => [p.id, p.name]));

    groupEnrollments.forEach(enrollment => {
      enrollment.providerName = providerMap.get(enrollment.providerId) || 'N/A';
      const planInfo = planMap.get(enrollment.payerPlanId);
      if (planInfo) {
        enrollment.payerPlanName = planInfo.name || 'N/A';
        enrollment.payerName = payerMap.get(planInfo.payerId) || 'N/A';
      } else {
        enrollment.payerPlanName = 'N/A';
        enrollment.payerName = 'N/A';
      }
    });

    groupEnrollments.sort((a, b) => {
      const valA = a[sortBy] || '';
      const valB = b[sortBy] || '';
      let comparison = 0;
      if (sortBy.toLowerCase().includes('date') && valA && valB) {
         comparison = new Date(valA) > new Date(valB) ? 1 : -1;
      } else {
        if (String(valA).toLowerCase() > String(valB).toLowerCase()) {
          comparison = 1;
        } else if (String(valA).toLowerCase() < String(valB).toLowerCase()) {
          comparison = -1;
        }
      }
      return sortOrder === 'desc' ? comparison * -1 : comparison;
    });

    const totalRecords = groupEnrollments.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = groupEnrollments.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list group enrollments for group ${groupId}: ${error.message}`);
    return { success: false, message: `Failed to list group enrollments: ${error.message}` };
  }
}

/**
 * Adds or removes providers from a group.
 * @param {string} groupId The ID of the group to modify.
 * @param {object} body An object with 'add' and/or 'remove' arrays of provider IDs.
 * @returns {object} A success or error message.
 */
function patchGroupProviderRelation(groupId, body) {
  try {
    if (!groupId || !body) {
      return { success: false, message: "Group ID and a body with 'add' or 'remove' arrays are required." };
    }
    const sheet = getSheet(GROUP_PROVIDERS_SHEET_NAME, GROUP_PROVIDERS_HEADERS);
    let changesMade = false;

    if (body.remove && body.remove.length > 0) {
      const data = sheet.getDataRange().getValues();
      const providerIdsToRemove = new Set(body.remove);
      for (let i = data.length - 1; i >= 1; i--) {
        const rowGroupId = data[i][0];
        const rowProviderId = data[i][1];
        if (rowGroupId === groupId && providerIdsToRemove.has(rowProviderId)) {
          sheet.deleteRow(i + 1);
          changesMade = true;
        }
      }
    }

    if (body.add && body.add.length > 0) {
      const existingProviderIds = new Set(
        sheet.getDataRange().getValues()
          .filter(row => row[0] === groupId)
          .map(row => row[1])
      );
      const newRows = body.add
        .filter(providerId => !existingProviderIds.has(providerId))
        .map(providerId => [groupId, providerId]);
      
      if (newRows.length > 0) {
        sheet.getRange(sheet.getLastRow() + 1, 1, newRows.length, newRows[0].length).setValues(newRows);
        changesMade = true;
      }
    }

    if (changesMade) {
      invalidateRowIndexCache(sheet);
      logAuditEvent("Request", `Patched provider relations for group ${groupId}`, { groupId: groupId, changes: body });
      return { success: true, message: "Group-provider relations updated successfully." };
    } else {
      return { success: true, message: "No changes made to group-provider relations." };
    }
  } catch (error) {
    logAuditEvent("Error", `Failed to patch group-provider relations for group ${groupId}: ${error.message}`);
    return { success: false, message: `Failed to patch group-provider relations: ${error.message}` };
  }
}

/**
 * Adds or removes payers from a group.
 * @param {string} groupId The ID of the group to modify.
 * @param {object} body An object with 'add' and/or 'remove' arrays of payer IDs.
 * @returns {object} A success or error message.
 */
function patchGroupPayerRelation(groupId, body) {
  try {
    if (!groupId || !body) {
      return { success: false, message: "Group ID and a body with 'add' or 'remove' arrays are required." };
    }
    const sheet = getSheet(GROUP_PAYERS_SHEET_NAME, GROUP_PAYERS_HEADERS);
    let changesMade = false;

    if (body.remove && body.remove.length > 0) {
      const data = sheet.getDataRange().getValues();
      const payerIdsToRemove = new Set(body.remove);
      for (let i = data.length - 1; i >= 1; i--) {
        const rowGroupId = data[i][0];
        const rowPayerId = data[i][1];
        if (rowGroupId === groupId && payerIdsToRemove.has(rowPayerId)) {
          sheet.deleteRow(i + 1);
          changesMade = true;
        }
      }
    }

    if (body.add && body.add.length > 0) {
      const existingPayerIds = new Set(
        sheet.getDataRange().getValues()
          .filter(row => row[0] === groupId)
          .map(row => row[1])
      );
      const newRows = body.add
        .filter(payerId => !existingPayerIds.has(payerId))
        .map(payerId => [groupId, payerId]);
      
      if (newRows.length > 0) {
        sheet.getRange(sheet.getLastRow() + 1, 1, newRows.length, newRows[0].length).setValues(newRows);
        changesMade = true;
      }
    }

    if (changesMade) {
      invalidateRowIndexCache(sheet);
      logAuditEvent("Request", `Patched payer relations for group ${groupId}`, { groupId: groupId, changes: body });
      return { success: true, message: "Group-payer relations updated successfully." };
    } else {
      return { success: true, message: "No changes made to group-payer relations." };
    }
  } catch (error) {
    logAuditEvent("Error", `Failed to patch group-payer relations for group ${groupId}: ${error.message}`);
    return { success: false, message: `Failed to patch group-payer relations: ${error.message}` };
  }
}

// --- Definitions & Files Functions ---

/**
 * Lists all countries.
 * @returns {object} An object containing success status and a list of countries.
 */
function listCountries() {
  try {
    const sheet = getSheet(COUNTRIES_SHEET_NAME, COUNTRIES_HEADERS);
    const countries = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: countries };
  } catch (error) {
    logAuditEvent("Error", `Failed to list countries: ${error.message}`);
    return { success: false, message: `Failed to list countries: ${error.message}` };
  }
}

/**
 * Lists all provider types.
 * @returns {object} An object containing success status and a list of provider types.
 */
function listProviderTypes() {
  try {
    const sheet = getSheet(PROVIDER_TYPES_SHEET_NAME, PROVIDER_TYPES_HEADERS);
    const providerTypes = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: providerTypes };
  } catch (error) {
    logAuditEvent("Error", `Failed to list provider types: ${error.message}`);
    return { success: false, message: `Failed to list provider types: ${error.message}` };
  }
}

/**
 * Lists all facility license types.
 * @returns {object} An object containing success status and a list of facility license types.
 */
function listFacilityLicenseTypes() {
  try {
    const sheet = getSheet(FACILITY_LICENSE_TYPES_SHEET_NAME, FACILITY_LICENSE_TYPES_HEADERS);
    const facilityLicenseTypes = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: facilityLicenseTypes };
  } catch (error) {
    logAuditEvent("Error", `Failed to list facility license types: ${error.message}`);
    return { success: false, message: `Failed to list facility license types: ${error.message}` };
  }
}

/**
 * Lists all facility taxonomies.
 * @returns {object} An object containing success status and a list of facility taxonomies.
 */
function listFacilityTaxonomies() {
  try {
    const sheet = getSheet(FACILITY_TAXONOMIES_SHEET_NAME, FACILITY_TAXONOMIES_HEADERS);
    const taxonomies = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: taxonomies };
  } catch (error) {
    logAuditEvent("Error", `Failed to list facility taxonomies: ${error.message}`);
    return { success: false, message: `Failed to list facility taxonomies: ${error.message}` };
  }
}

/**
 * Lists available license types for providers.
 * @returns {object} An object containing success status and a list of license types.
 */
function listSimplifiedLicenseTypes() {
  try {
    const sheet = getSheet(LICENSE_TYPES_SHEET_NAME, LICENSE_TYPES_HEADERS);
    const licenseTypes = sheetDataToObjects(sheet.getDataRange().getValues());
    return { success: true, data: licenseTypes };
  } catch (error) {
    logAuditEvent("Error", `Failed to list license types: ${error.message}`);
    return { success: false, message: `Failed to list license types: ${error.message}` };
  }
}

/**
 * Lists uploaded files with pagination and filtering.
 * @param {object} [options={}] Query parameters for pagination and filtering.
 * @returns {object} An object with the list of files and pagination info.
 */
function listUploadedFilesMetadata(options = {}) {
  try {
    const { page = 1, pageSize = 15, searchTerm = '', providerId, facilityId } = options;

    const filesSheet = getSheet(FILES_SHEET_NAME, FILES_HEADERS);
    let allFiles = sheetDataToObjects(filesSheet.getDataRange().getValues());

    // Filtering
    if (providerId) {
      allFiles = allFiles.filter(file => file.providerId === providerId);
    }
    if (facilityId) {
      allFiles = allFiles.filter(file => file.facilityId === facilityId);
    }
    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allFiles = allFiles.filter(file => {
        const fileName = file.path ? decodeURIComponent(file.path.substring(file.path.lastIndexOf('/') + 1)).toLowerCase() : '';
        return fileName.includes(lowercasedTerm) ||
               (file.id && file.id.toLowerCase().includes(lowercasedTerm)) ||
               (file.createdByUserEmail && file.createdByUserEmail.toLowerCase().includes(lowercasedTerm));
      });
    }

    // Enrich data
    const providers = sheetDataToObjects(getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS).getDataRange().getValues());
    const facilities = sheetDataToObjects(getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS).getDataRange().getValues());
    const providerMap = new Map(providers.map(p => [p.id, `${p.firstName} ${p.lastName}`]));
    const facilityMap = new Map(facilities.map(f => [f.id, f.name]));

    allFiles.forEach(file => {
      if (file.providerId) {
        file.entityName = providerMap.get(file.providerId) || 'Unknown Provider';
        file.entityType = 'Provider';
      } else if (file.facilityId) {
        file.entityName = facilityMap.get(file.facilityId) || 'Unknown Facility';
        file.entityType = 'Facility';
      } else {
        file.entityName = 'N/A';
        file.entityType = 'Unlinked';
      }
    });

    // Sorting (newest first)
    allFiles.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    // Pagination
    const totalRecords = allFiles.length;
    const startIndex = (page - 1) * pageSize;
    const paginatedData = allFiles.slice(startIndex, startIndex + pageSize);

    return { success: true, data: paginatedData, totalRecords: totalRecords };
  } catch (error) {
    logAuditEvent("Error", `Failed to list uploaded files: ${error.message}`);
    return { success: false, message: `Failed to list uploaded files: ${error.message}` };
  }
}

// --- Helper for CSV Export ---

/**
 * Converts an array of JavaScript objects into a CSV string.
 * Assumes all objects have the same keys as the headers.
 * Handles JSON fields by stringifying them.
 * @param {Array<string>} headers - An array of header names in the desired order.
 * @param {Array<object>} data - An array of objects to convert.
 * @returns {string} The CSV formatted string.
 */
function convertObjectsToCsvString(headers, data) {
  if (!data || data.length === 0) {
    return headers.join(',') + '\n'; // Return headers even if no data
  }

  // Map backend object keys to original header names for correct ordering and value extraction
  const headerKeys = headers.map(header => {
    const key = header.replace(/(?:^|\s)\S/g, a => a.toUpperCase()).replace(/\s/g, '').replace(/\(JSON\)/g, '');
    return key.charAt(0).toLowerCase() + key.slice(1);
  });

  const csvRows = [];
  csvRows.push(headers.join(',')); // Add header row

  data.forEach(rowObject => {
    const values = headerKeys.map(key => {
      let value = rowObject[key];
      if (value === null || value === undefined) {
        value = '';
      } else if (typeof value === 'object') {
        value = JSON.stringify(value); // Stringify JSON objects/arrays
      } else {
        value = String(value); // Ensure all values are strings
      }
      // Escape double quotes and enclose in double quotes if value contains comma or double quote
      if (value.includes(',') || value.includes('"') || value.includes('\n')) {
        value = '"' + value.replace(/"/g, '""') + '"';
      }
      return value;
    });
    csvRows.push(values.join(','));
  });

  return csvRows.join('\n');
}


// --- Export Functions for various entities ---

/**
 * Exports all providers to a CSV string.
 * Applies optional search, sort, and filter parameters before export.
 * @param {object} options - Options for filtering and sorting.
 * @returns {object} A success object with the CSV string.
 */
function exportProvidersToCsv(options = {}) {
  try {
    // Re-use the getProviders logic but without pagination
    const { searchTerm = '', sortBy = 'lastName', sortOrder = 'asc' } = options;
    const sheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    let allProviders = sheetDataToObjects(sheet.getDataRange().getValues());

    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allProviders = allProviders.filter(p => {
        const fullName = `${p.firstName || ''} ${p.lastName || ''}`.toLowerCase();
        return (p.id && p.id.toLowerCase().includes(lowercasedTerm)) ||
               fullName.includes(lowercasedTerm) ||
               (p.npi && p.npi.toString().includes(lowercasedTerm));
      });
    }

    if (sortBy) {
      allProviders.sort((a, b) => {
        const valA = a[sortBy] || '';
        const valB = b[sortBy] || '';
        let comparison = 0;
        if (valA > valB) {
          comparison = 1;
        } else if (valA < valB) {
          comparison = -1;
        }
        return sortOrder === 'desc' ? comparison * -1 : comparison;
      });
    }

    const csvString = convertObjectsToCsvString(PROVIDERS_HEADERS, allProviders);
    return { success: true, data: csvString, filename: `providers_export_${new Date().toISOString().split('T')[0]}.csv` };
  } catch (error) {
    logAuditEvent("Error", `Failed to export providers to CSV: ${error.message}`);
    return { success: false, message: `Failed to export providers: ${error.message}` };
  }
}

/**
 * Exports all facilities to a CSV string.
 * Applies optional search, sort, and filter parameters before export.
 * @param {object} options - Options for filtering and sorting.
 * @returns {object} A success object with the CSV string.
 */
function exportFacilitiesToCsv(options = {}) {
  try {
    const { searchTerm = '', sortBy = 'name', sortOrder = 'asc' } = options;
    const sheet = getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS);
    let allFacilities = sheetDataToObjects(sheet.getDataRange().getValues());

    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allFacilities = allFacilities.filter(f => {
        const nameMatch = f.name && f.name.toLowerCase().includes(lowercasedTerm);
        const cityMatch = f.city && f.city.toLowerCase().includes(lowercasedTerm);
        const stateMatch = f.state && f.state.toLowerCase().includes(lowercasedTerm);
        const idMatch = f.id && f.id.toLowerCase().includes(lowercasedTerm);
        return nameMatch || cityMatch || stateMatch || idMatch;
      });
    }

    if (sortBy) {
      allFacilities.sort((a, b) => {
        const valA = a[sortBy] || '';
        const valB = b[sortBy] || '';
        let comparison = 0;
        if (valA > valB) {
          comparison = 1;
        } else if (valA < valB) {
          comparison = -1;
        }
        return sortOrder === 'desc' ? comparison * -1 : comparison;
      });
    }

    const csvString = convertObjectsToCsvString(FACILITIES_HEADERS, allFacilities);
    return { success: true, data: csvString, filename: `facilities_export_${new Date().toISOString().split('T')[0]}.csv` };
  } catch (error) {
    logAuditEvent("Error", `Failed to export facilities to CSV: ${error.message}`);
    return { success: false, message: `Failed to export facilities: ${error.message}` };
  }
}

/**
 * Exports all notes to a CSV string.
 * Applies optional search term before export.
 * @param {object} options - Options for filtering.
 * @returns {object} A success object with the CSV string.
 */
function exportAllNotesToCsv(options = {}) {
  try {
    const { searchTerm = '' } = options;
    const sheet = getSheet(NOTES_SHEET_NAME, NOTES_HEADERS);
    let allNotes = sheetDataToObjects(sheet.getDataRange().getValues());

    // Enrich notes with entity names for better context in CSV
    const providers = sheetDataToObjects(getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS).getDataRange().getValues());
    const facilities = sheetDataToObjects(getSheet(FACILITIES_SHEET_NAME, FACILITIES_HEADERS).getDataRange().getValues());
    const requests = sheetDataToObjects(getSheet(CREDENTIALING_REQUESTS_SHEET_NAME, CREDENTIALING_REQUESTS_HEADERS).getDataRange().getValues());

    const providerMap = new Map(providers.map(p => [p.id, `${p.firstName} ${p.lastName}`]));
    const facilityMap = new Map(facilities.map(f => [f.id, f.name]));
    const requestMap = new Map(requests.map(r => [r.id, `Request ${r.id.substring(0, 8)}...`]));

    allNotes.forEach(note => {
      if (note.providerId) {
        note.entityName = providerMap.get(note.providerId) || 'Unknown Provider';
        note.entityType = 'Provider';
      } else if (note.facilityId) {
        note.entityName = facilityMap.get(note.facilityId) || 'Unknown Facility';
        note.entityType = 'Facility';
      } else if (note.requestId) {
        note.entityName = requestMap.get(note.requestId) || 'Unknown Request';
        note.entityType = 'Request';
      } else {
        note.entityName = 'N/A';
        note.entityType = 'Unlinked';
      }
    });

    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allNotes = allNotes.filter(note =>
        (note.note && note.note.toLowerCase().includes(lowercasedTerm)) ||
        (note.userEmail && note.userEmail.toLowerCase().includes(lowercasedTerm)) ||
        (note.entityName && note.entityName.toLowerCase().includes(lowercasedTerm)) ||
        (note.providerId && note.providerId.toLowerCase().includes(lowercasedTerm)) ||
        (note.facilityId && note.facilityId.toLowerCase().includes(lowercasedTerm)) ||
        (note.requestId && note.requestId.toLowerCase().includes(lowercasedTerm))
      );
    }

    // Define headers for the CSV, including enriched fields
    const exportHeaders = [...NOTES_HEADERS, 'Entity Type', 'Entity Name'];
    const csvString = convertObjectsToCsvString(exportHeaders, allNotes);
    return { success: true, data: csvString, filename: `notes_export_${new Date().toISOString().split('T')[0]}.csv` };
  } catch (error) {
    logAuditEvent("Error", `Failed to export notes to CSV: ${error.message}`);
    return { success: false, message: `Failed to export notes: ${error.message}` };
  }
}

/**
 * Exports provider enrollments to a CSV string.
 * @param {string} providerId - The ID of the provider to export enrollments for.
 * @returns {object} A success object with the CSV string.
 */
function exportProviderEnrollmentsToCsv(providerId) {
  try {
    if (!providerId) {
      return { success: false, message: "Provider ID is required to export enrollments." };
    }
    const enrollmentsSheet = getSheet(PROVIDER_ENROLLMENTS_SHEET_NAME, PROVIDER_ENROLLMENTS_HEADERS);
    let allEnrollments = sheetDataToObjects(enrollmentsSheet.getDataRange().getValues());
    let providerEnrollments = allEnrollments.filter(e => e.providerId === providerId);

    // Enrich enrollments with names for better context
    const groups = sheetDataToObjects(getSheet(GROUPS_SHEET_NAME, GROUPS_HEADERS).getDataRange().getValues());
    const plans = sheetDataToObjects(getSheet(PAYER_PLANS_SHEET_NAME, PAYER_PLANS_HEADERS).getDataRange().getValues());
    const payers = sheetDataToObjects(getSheet(PAYERS_SHEET_NAME, PAYERS_HEADERS).getDataRange().getValues());
    const provider = sheetDataToObjects(getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS).getDataRange().getValues()).find(p => p.id === providerId);

    const groupMap = new Map(groups.map(g => [g.id, g.name]));
    const planMap = new Map(plans.map(p => [p.id, {name: p.name, payerId: p.payerId}]));
    const payerMap = new Map(payers.map(p => [p.id, p.name]));

    providerEnrollments.forEach(enrollment => {
      enrollment.providerName = provider ? `${provider.firstName} ${provider.lastName}` : 'N/A';
      enrollment.groupName = groupMap.get(enrollment.groupId) || 'N/A';
      const planInfo = planMap.get(enrollment.payerPlanId);
      if (planInfo) {
        enrollment.payerPlanName = planInfo.name || 'N/A';
        enrollment.payerName = payerMap.get(planInfo.payerId) || 'N/A';
      } else {
        enrollment.payerPlanName = 'N/A';
        enrollment.payerName = 'N/A';
      }
    });

    // Define headers for the CSV, including enriched fields
    const exportHeaders = [
      ...PROVIDER_ENROLLMENTS_HEADERS,
      'Provider Name', 'Group Name', 'Payer Name', 'Payer Plan Name'
    ];
    const csvString = convertObjectsToCsvString(exportHeaders, providerEnrollments);
    return { success: true, data: csvString, filename: `enrollments_for_${providerId.substring(0, 8)}_export_${new Date().toISOString().split('T')[0]}.csv` };
  } catch (error) {
    logAuditEvent("Error", `Failed to export provider enrollments to CSV: ${error.message}`);
    return { success: false, message: `Failed to export enrollments: ${error.message}` };
  }
}

/**
 * Exports all provider licenses to a CSV string.
 * Applies optional search, sort, and filter parameters before export.
 * @param {object} options - Options for filtering and sorting.
 * @returns {object} A success object with the CSV string.
 */
function exportAllProviderLicensesToCsv(options = {}) {
  try {
    const { searchTerm = '', status = '', state = '', licenseTypeId = '', sortBy = 'licenseNumber', sortOrder = 'asc' } = options;

    const licensesSheet = getSheet(LICENSES_SHEET_NAME, LICENSES_HEADERS);
    let allLicenses = sheetDataToObjects(licensesSheet.getDataRange().getValues());

    // Filter by search term
    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      allLicenses = allLicenses.filter(l =>
        (l.licenseNumber && l.licenseNumber.toLowerCase().includes(lowercasedTerm)) ||
        (l.firstName && l.firstName.toLowerCase().includes(lowercasedTerm)) ||
        (l.lastName && l.lastName.toLowerCase().includes(lowercasedTerm)) ||
        (l.state && l.state.toLowerCase().includes(lowercasedTerm)) ||
        (l.currentVerificationStatus && l.currentVerificationStatus.toLowerCase().includes(lowercasedTerm))
      );
    }

    // Filter by specific criteria
    if (status) {
      allLicenses = allLicenses.filter(l => l.currentVerificationStatus === status);
    }
    if (state) {
      allLicenses = allLicenses.filter(l => l.state === state);
    }
    if (licenseTypeId) {
      allLicenses = allLicenses.filter(l => l.licenseTypeId === licenseTypeId);
    }

    // Enrich with Provider Names and License Type Names
    const providersSheet = getSheet(PROVIDERS_SHEET_NAME, PROVIDERS_HEADERS);
    const allProviders = sheetDataToObjects(providersSheet.getDataRange().getValues());
    const providerMap = new Map(allProviders.map(p => [p.id, `${p.firstName} ${p.lastName}`]));

    const licenseTypesSheet = getSheet(LICENSE_TYPES_SHEET_NAME, LICENSE_TYPES_HEADERS);
    const allLicenseTypes = sheetDataToObjects(licenseTypesSheet.getDataRange().getValues());
    const licenseTypeMap = new Map(allLicenseTypes.map(lt => [lt.id, lt.name]));

    allLicenses.forEach(license => {
      license.providerName = providerMap.get(license.providerId) || 'Unknown Provider';
      license.licenseTypeName = licenseTypeMap.get(license.licenseTypeId) || 'Unknown Type';
    });

    // Sorting
    allLicenses.sort((a, b) => {
      const valA = a[sortBy] || '';
      const valB = b[sortBy] || '';

      let comparison = 0;
      if (sortBy.includes('Date')) {
        comparison = new Date(valA) > new Date(valB) ? 1 : -1;
      } else {
        if (String(valA).toLowerCase() > String(valB).toLowerCase()) {
          comparison = 1;
        } else if (String(valA).toLowerCase() < String(valB).toLowerCase()) {
          comparison = -1;
        }
      }
      return sortOrder === 'desc' ? comparison * -1 : comparison;
    });

    // Define headers for the CSV, including enriched fields
    const exportHeaders = [
      ...LICENSES_HEADERS,
      'Provider Name', 'License Type Name'
    ];
    const csvString = convertObjectsToCsvString(exportHeaders, allLicenses);
    return { success: true, data: csvString, filename: `all_licenses_export_${new Date().toISOString().split('T')[0]}.csv` };

  } catch (error) {
    logAuditEvent("Error", `Failed to export all provider licenses to CSV: ${error.message}`);
    return { success: false, message: `Failed to export all licenses: ${error.message}` };
  }
}